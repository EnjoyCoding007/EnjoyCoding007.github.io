<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《视觉开发专题》之 OpenGL 概述</title>
      <link href="/2019/05/21/%E3%80%8A%E8%A7%86%E8%A7%89%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98%E3%80%8B%E4%B9%8B%20OpenGL%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/05/21/%E3%80%8A%E8%A7%86%E8%A7%89%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98%E3%80%8B%E4%B9%8B%20OpenGL%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>这是 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2JjNjg0N2YyNjVkYTAzYjQ0NjEwMWU=" title="https://juejin.im/post/5cbc6847f265da03b446101e"><strong>视觉专题</strong><i class="fa fa-external-link"></i></span> 的第一篇，将分为：</p><ol><li><strong>什么是 OpenGL</strong></li><li><strong>OpenGL 语法说明</strong></li><li><strong>OpenGL 渲染管线</strong></li><li><strong>OpenGL 程序&amp;渲染流程分析</strong>  </li></ol><p>这几个小模块来一一介绍，阅读完本篇内容你将收获：</p><ol><li><strong>OpenGL 是什么</strong></li><li><strong>OpenGL 渲染管线的工作流程</strong></li></ol><p>友情提示：该篇文字较多，比较适合对 OpenGL 知之甚少的同学阅读，已经有相关经验的大佬可以溜了😝，闲言少叙，直入正题。</p><p>注：<br>该专题默认使用<strong>核心模式</strong>来进行，需要 OpenGL 的版本在3.3以上。</p><hr><h3 id="一：什么是-OpenGL"><a href="#一：什么是-OpenGL" class="headerlink" title="一：什么是 OpenGL"></a>一：什么是 OpenGL</h3><p>&emsp; 一般它被认为是一个<strong>API</strong> (Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数（通过直接访问图形硬件设备的特性来实现）。事实上，OpenGL 本身并不是一个API，它仅仅是一个由 Khronos 组织制定并维护的<span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsLw==" title="https://www.khronos.org/opengl/">规范<i class="fa fa-external-link"></i></span>(Specification)。  </p><p>&emsp; OpenGL 规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由 OpenGL 库的开发者自行决定（这里开发者通常是显卡的生产商）。  </p><p>&emsp; 因为 OpenGL 规范并没有规定实现的细节，具体的 OpenGL 库允许使用不同的实现，只要其功能和结果与规范相匹配即可。所以，当你使用 Apple 系统的时候，OpenGL 库是由 Apple 自身维护的。在 Linux 下，有显卡生产商提供的 OpenGL 库，也有一些爱好者改编的版本。这也意味着任何时候 OpenGL 库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。</p><p>&emsp; OpenGL 是使用客户端 - 服务端的形式实现的，我们编写的应用程序可以看做客户端，而计算机图形硬件厂商所提供的 OpenGL 实现可以看做服务端。我们编写的 OpenGL 命令，最终会被转换为相关的协议提交给服务端，然后被执行并产生图像内容。</p><hr><h3 id="二：OpenGL-语法"><a href="#二：OpenGL-语法" class="headerlink" title="二：OpenGL 语法"></a>二：OpenGL 语法</h3><p>&emsp; OpenGL 库中所有的函数都会以字符“gl”作为前缀，然后是个或多个大写字母开头的词组，以此来命名一个完成的函数（如 <strong>glBinVertexArray()</strong>）。除此之外你还会看到“glfw”开头的函数，它们来自第三方库 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2xmdy5vcmcv" title="https://www.glfw.org/">GLFW<i class="fa fa-external-link"></i></span>，这是一个抽象化窗口管理和其他系统任务的开发库。类似的，还有“gl3w”开头的函数，它们来自三方库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NrYXNsZXYvZ2wzdw==" title="https://github.com/skaslev/gl3w">GL3W<i class="fa fa-external-link"></i></span>。后续会进一步展开讲这两个库的内容。</p><p>&emsp; 与函数命名约定类似，OpenGL 库中定义的常量采用“GL_”开头，通过<code>#define</code>来完成常量的定义。为了方便在不同的操作系统之间移植 OpenGL 程序，OpenGL 还为函数定义了不同的数据类型，如<code>GLfloat</code>，所以最好统一使用 OpenGL 定义的数据类型，这样就不需要关心系统兼容性问题了。</p><p>&emsp; 由于 OpenGL 是一个 C 语言形式的库，因此它不能使用函数的重载来处理不同类型的数据，它通过函数名称的细微变化来实现同一类功能函数集的管理。举个例子：<code>glUniform2f()</code>与<code>glUniform3fv()</code>，前者的后缀<code>2f</code>表示这个函数需要两个<code>GLfloat</code> 类型的参数（以此类推，目前一共定义了24种不同的<code>glUniform*</code>()函数），后者的后缀多出的一个<code>v</code>是 vector 的缩写，即表示它需要传入一个包含三个 <code>GLfloat</code> 类型元素的一维数组作为参数。</p><p>所有可以作为后缀的字母，以及它们所对应的数据类型：<br><img src="https://user-gold-cdn.xitu.io/2019/5/12/16aabe00fec10dff?w=2418&amp;h=724&amp;f=png&amp;s=2917032" alt></p><hr><h3 id="三：OpenGL-渲染管线"><a href="#三：OpenGL-渲染管线" class="headerlink" title="三：OpenGL 渲染管线"></a>三：OpenGL 渲染管线</h3><p>&emsp; 早期的（3.3版本以前） OpenGL 使用<strong>立即渲染模式</strong>(Immediate mode，即固定渲染管线)：OpenGL的大多数功能都被库隐藏起来，开发者很少能控制 OpenGL 计算的过程。固定渲染管线较容易使用和理解，但是效率太低且不够灵活。</p><p>&emsp; 当使用OpenGL的核心模式时，OpenGL 迫使我们使用现代的函数，现代函数具有更高的灵活性和效率性，也能让人更容易清楚 OpenGL 是如何运作的，更好的理解图形编程。但入门门槛也稍有增加。</p><p>&emsp; 我们通常所说的<strong>渲染管线</strong>(rendering pipeline)，它包含了两个部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。下图是 OpenGL4.5 版本的<strong>管线</strong>示意图：<br><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9ccac2598e33?w=2088&amp;h=1090&amp;f=png&amp;s=328729" alt><br>&emsp; OpenGL 首先接收用户提供的几何数据（顶点和几何图元），并且将它输入到一系列着色器阶段中进行处理，然后将处理后的数据送入光栅化单元(rasterizer)。光栅化单元负责对所有剪切区域内的图元生成片元数据，我们可以将一个片元视为一个“候选的像素”，然后对每个生成的片元都执行一个片元着色器，这一步会计算出这个片元的最终颜色。注意，即使在片元着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同，还会受<strong>深度</strong>和<strong>混合</strong>的影响，这个后面会详细讲。</p><p>&emsp; 我们可以通过控制我们需要的着色器来实现自己所需的功能，事实上，只有顶点着色器和片元着色器是必需的，细分和几何是可选的步骤。为了更好理解顶点着色器和片元着色器的分工和区别，可以总结为：<strong>顶点着色（包括细分和几何着色）决定了一个图元应该位于屏幕的什么位置，而片元着色使用这些信息来决定某个片元的颜色应该是什么</strong>。</p><hr><h3 id="五：OpenGL-程序-amp-渲染流程分析"><a href="#五：OpenGL-程序-amp-渲染流程分析" class="headerlink" title="五：OpenGL 程序&amp;渲染流程分析"></a>五：OpenGL 程序&amp;渲染流程分析</h3><p>无论 OpenGL 的程序写的有多么庞大与复杂，它的基本结构通常都是类似的：</p><ol><li>初始化物体渲染所对应的状态。</li><li>设置需要渲染的物体。</li></ol><p>在上代码之前，咱们需要对必要的图形学名词有基本的理解。</p><ul><li><strong>渲染</strong>：计算机从模型到最终的图像创建的过程。OpenGL 只是计算机渲染系统的其中一种，基于光栅化的系统。 Object，IBO. 决定了绘制顶点的顺序，避免顶点数据重复造成的资源浪费。</li><li><strong>OpenGL 状态机</strong>：可以看做一个上下文(context)，在调用任何 OpenGL 的指令之前，都需要先创建并进入这样的上下文中，它可以记录自己当前的状态，并能接收新的输入（调用 OpenGL 函数），当关闭了上下文，就不再接收输入。</li><li><strong>着色器 (Shader)</strong>：为<strong>图形渲染管线</strong>中的某个特定部分，将输入转化为输出的程序。在 OpenGL 中，会涉及到六种不同的着色阶段，其中最常用的包括<strong>顶点着色器</strong>以及<strong>片元着色器</strong>，前者用于处理顶点数据，后者用于处理光栅化后的片元数据。着色器运行在 GPU 上，在 OpenGL 使用它之前，必须经过编译并链接为一个<strong>着色器程序对象</strong>(Shader Program Object)。  </li></ul><p>一个简单顶点着色器的源代码长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">    gl_Position = ftransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单片元着色器的源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    gl_FragColor = vec4(1.0,0.5,0.2,1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它们都需要用 <span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsL3dpa2kvQ29yZV9MYW5ndWFnZV8oR0xTTA==" title="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL">GLSL<i class="fa fa-external-link"></i></span>) (OpenGL Shading Language，着色器语言) 。</p><ul><li><strong>标准化设备坐标(Normalized Device Coordinates, NDC)</strong>：一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。</li><li><strong>像素</strong>：显示器上最小的可见单元。</li><li><strong>帧缓存</strong>：保存着所有计算机生成的图像的像素点，它是由图形硬件设备管理的一块独立内存区域，可以直接映射到最终的显示设备上。</li><li><strong>顶点缓冲对象</strong>：Vertex Buffer Object，<strong>VBO</strong>. 管理着在GPU内存（通常被称为显存）中，一块储存着大量顶点数据的内存。因为从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。</li><li><p><strong>顶点数组对象</strong>：Vertex Array Object，<strong>VAO</strong>. 可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO 中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单。<br><img src="https://user-gold-cdn.xitu.io/2019/5/20/16ad4360a31608cf?w=546&amp;h=369&amp;f=png&amp;s=28360" alt><br>当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p></li><li><p><strong>索引缓冲对象</strong>：Element Buffer Object，EBO或Index Buffer. 专门储存顶点绘制的索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。由于三角形是绘制的基本图形，对于一些复杂图形会存在很多三角形（共用边）的顶点重合问题，该索引就是为了解决此问题，从而降低开销。</p></li></ul><p>我写了一份简单的 OpenGL <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vuam95Q29kaW5nMDA3L09wZW5HTC1TaW1wbGUtRGVtbw==" title="https://github.com/EnjoyCoding007/OpenGL-Simple-Demo">示例程序<i class="fa fa-external-link"></i></span> 给你作参考，附有比较详细的渲染流程分析，需要的同学自取，这里就不占篇幅粘代码了。用 Xcode 打开程序直接 Run， 就可以看到该效果：<br><img src="https://user-gold-cdn.xitu.io/2019/5/21/16ad9dd29af3a5a0?w=1600&amp;h=1244&amp;f=png&amp;s=52945" alt>这份 Demo 使用了可编程渲染管线，自定义了简单的着色器，初学者不需要搞清楚每一步的原理，先对 OpenGL 的语法和基本结构有个初步的了解就行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp; 枯燥的概念和晦涩的专业术语很容易让初学者望而生畏，所以此篇我只选了一些必要的概念，做了简要的介绍。建议结合文中提供的源码，把上面涉及到的步骤一一拆解，进而加深对相关概念以及 OpenGL 工作流程的理解。</p><p>&emsp; 近来因工作和身体原因，文章更新滞后了两周有余，现已恢复正常。</p><p>&emsp; 下一篇文章将使用<strong>固定管线</strong>来完成一些动画效果，顺带介绍涉及到的 OpenGL 知识，这样更便于理解。</p>]]></content>
      
      
      <categories>
          
          <category> 图形编程 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/23/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B/"/>
      <url>/2019/04/23/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<hr><p>categories: [成长,方法]<br>tags: 方法</p><h2 id="title-如何成为有效学习的高手"><a href="#title-如何成为有效学习的高手" class="headerlink" title="title: 如何成为有效学习的高手"></a>title: 如何成为有效学习的高手</h2><blockquote><p>不闲言赘语，直戳痛点，放下借口，共同面对内心的忐忑吧。</p><p>注：本文为得到专栏付费课程学习心得，分享给大家一起加快成长速度。</p></blockquote><p>&emsp;高效学习，它没有一种准确的定义，它更是对一种学习状态的描述，一万小时理论我们都听过，但这个理论可能不适合我们99.9%的人，我想这个理论出现的目的其实是为了推翻人们对于天才的迷信，但是，一万小时理论所展现的那种学习或者说练习的场景跟你和我的生活、工作离得都很远，我们也不需要都成为世界级的高手。这个理论本身没有错，它在打破人们对于天才的迷信的同时，也打击了绝大部分成年人的信心：谁有功夫每天8小时练习，练10年呢？但我们常常需要在很短的时间里要掌握一些技能，而且要达到专业级别的水准，这要求我们必须在有限的业余碎片时间中，高效的有目的的学习，话不多说，进入正题。</p><h3 id="让我们从七个关键词着手："><a href="#让我们从七个关键词着手：" class="headerlink" title="让我们从七个关键词着手："></a>让我们从七个关键词着手：</h3><ol><li>适合自己</li><li>学习手法</li><li>短时间</li><li>注意力</li><li>解决难题</li><li>设定目标</li><li>名师</li></ol><p>接下来我会对这七个关键词主义展开来探讨，学习如何将他们有机的结合起来，形成一套可自控，可循环，甚至是可以升级的学习套路。此篇先消化前两个关键词。</p><h4 id="1-找到适合你的学习方法"><a href="#1-找到适合你的学习方法" class="headerlink" title="1.找到适合你的学习方法"></a>1.找到适合你的学习方法</h4><p>&emsp; 先重点要给大家介绍的两种学习思维，自然主义和结构主义。自然主义是模仿式的学习，自然主义注重文本的本身，什么是文本？就是一门知识或者技能它表面上看起来的样子，遇到什么就学什么，积少成多，以量取胜。学完了就那样了，它就是你自己的了，你就可以去运用了。结构主义它侧重对结构和交互关系的一个认识，它提倡透过表面的现象去寻求底层的关系。也就是说你要学习的是一套能举一反三的系统，这种诉求为的是什么呢？体系化的去学习，学会之后的目的，一定是为了创造，是一种质变，它要的是一种质变。选对学习方式这是第一步。（学习比如像语言、乐器、书法这些东西，你可能要用自然主义的学习方法去学习才更有效果。如果你学比如像医药、艺术，或者经济学，那就应该用结构主义的方式来学了。）</p><p>&emsp; 再谈谈学习速度和效率的提升，理论上可以分为两个阶段：第一是避免无效学习，也就是选对学习方式。然后就是尽可能通过更好的学习策略来把这个有效变为高效。最简单有效的技巧就是 ：  </p><p>&emsp; <strong>把你的目标要拆碎，针对那些细节进行反复的练习。不要一开始就照顾全局。</strong>  </p><p>如果还能以碎片化的方式挤出更多的时间来学习的话，那效果会更好。</p><h5 id="碎片化学习的真相"><a href="#碎片化学习的真相" class="headerlink" title="碎片化学习的真相"></a>碎片化学习的真相</h5><p>&emsp; 碎片化学习的真相是碎片化学习一定要基于搜索，搜索是什么意思？意思就是你要带着困惑和问题去执行碎片化的学习，最终的效果一定是要把这些碎片给链接起来。在一段时间内，你的头脑当中应该始终有一个课题，这些碎片它不是满地的落叶，而是我们可以把它比喻成一个打碎的瓷器所产生的碎片。你要有目的的去拾获这些碎片，而不是乱捡。就算碎片化知识是树叶，你也得先有树根、树干和树枝。碎片化学习要的是枝繁叶茂，而不是捡几片树叶回来夹在书里边。那就属于一种情绪化的行为。</p><p>&emsp; 话说回来，碎片化学习它终究是有局限性的，因为它缺乏思考，缺乏辩论，缺乏与人交流的这些环节。所谓学而不思则罔嘛。碎片划拉的越多，可能越糊涂了。但是，无论如何，碎片化学习作为一种成年人学习的补充手段，无疑它是有很大力量的。</p><p>&emsp; 我必须还要提醒你一件事情！！！有一种假的碎片化学习叫做收藏。你一定对这个东西非常熟悉，收藏这个按钮是非常常见的，在很多app和软件当中，所谓一种人性化的设置。它的存在能够非常大程度缓解人们的焦虑。但这种缓解它其实不是真正的缓解，它只是给你造成一种幻觉，就是收藏了这些知识就是你的了。但其实，如果你收藏完了不看的话，你不去碰它，它并不是你的。你必须要破除掉这种幻觉。</p><h4 id="2-不谈兴趣，用任务驱动学习"><a href="#2-不谈兴趣，用任务驱动学习" class="headerlink" title="2.不谈兴趣，用任务驱动学习"></a>2.不谈兴趣，用任务驱动学习</h4><p>&emsp; 学习，很多人提倡培养兴趣，让自己爱上学习，通常这些人最后都放弃了。以至于慢慢的习惯了没兴趣所以学不会、学不好的自我认知。学不会：连门都没入，这可能确实跟天赋有关，你让身高一米五的去打NBA这种情况我们就不讨论了；学不好：没达到某种专业的程度。兴趣无疑是最好的老师，这句话没毛病，但是如果明明没兴趣的东西，非要让你喜欢上它，这显然是极小概率事件，生活没时间给你去玩小概率。</p><p>&emsp; 一个很浅显的道理，人做任何事都是要回报的，所以一个人能带着多大的痛苦去做一件事，那是因为做成了这事儿会收获更大的利益。人做事的驱动有两个方面，一个是内部驱动，兴趣就是最大的内部驱动；一个是外部驱动，也就是完成目标之后收获的利益，既然你对该做的事没兴趣，那就干脆别浪费心思培养兴趣了，我要说的是，成年人学习不需要培养兴趣，应该用任务来驱动。你可能仍然会说，我没有任务啊，我找不到任务啊。任务到处都是，生活中的任务驱动，职场中的职业强迫，以教为学这些都是任务，找不到任务的唯一可能是你对未来的自己缺少预期。</p><p>&emsp; 生活中的驱动，比如厨艺、摄影、英语，现在的食品安全现状你还打算吃多久的外卖？想记录属于自己的美好记忆总觉得拍的照片经不起回味？出国游、面对各种英文文档没有翻译工具寸步难行？职场中的驱动，比如领域专业度、语言表达力、情绪与财富管理，部门每年加薪名额就那么点凭什么让老板优先考虑你呢？经常词不达意引起误会甚至错失良机？任性买买买快三十了还没房没车？以教为学，无论你学了什么，一旦你可以教别人了，你就不再是无业了。而且你还不是给人打工，你是自由职业者。以教为学一方面可以是自己对自己设置的一个任务和目标，不断地督促自己，另一方面其实会让你学的更好更透彻。</p><p>&emsp; 补充一点：你在心态上要有一种自觉，自己来聘请自己，让自我预期的小目标不断指引着持续学习，无论你在生活还是工作当中做任何事情都要这样做，不要心血来潮一股猛劲儿三分钟就疲了。</p><blockquote><p>愿你有所收获<br> ( ゜- ゜)つロ乾杯🍻</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视觉开发专题：OpenGL &amp; Metal  ( 苹果平台 )（目录持续更新中）</title>
      <link href="/2019/04/22/%E8%A7%86%E8%A7%89%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98%EF%BC%9AOpenGL%20&amp;%20Metal%20%20(%20%E8%8B%B9%E6%9E%9C%E5%B9%B3%E5%8F%B0%20)%EF%BC%88%E7%9B%AE%E5%BD%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2019/04/22/%E8%A7%86%E8%A7%89%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98%EF%BC%9AOpenGL%20&amp;%20Metal%20%20(%20%E8%8B%B9%E6%9E%9C%E5%B9%B3%E5%8F%B0%20)%EF%BC%88%E7%9B%AE%E5%BD%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>&emsp; 此前我们一直在围绕着 “iOS 逆向”这个专题在展开，最近出于工作&amp;职业规划的需要，要着手从零学习 iOS 视觉相关的知识了。当然，逆向相关的更新也会持续。  </p><p>&emsp; 可能很多同学看到 OpenGL 会有一丝担忧：苹果不是从 iOS 12 开始已经正式弃用 OpenGL 了吗，现在学 OpenGL 会不会没有直接学苹果自己的 Metal 收益高呢？个人觉得这个担心有些多余。且在该专题的更新计划中，也会覆盖到 Metal 框架，但会在 OpenGL（基于<strong>核心模式</strong>（可编程渲染管线）） 学习之后。  </p><p>&emsp; 学习新知识，于多数人而言，并不是“开头难”，难得是如何持续、系统的学完、学透。在音视频开发领域，入门门槛较高，目前适合初学者系统学习入门的参考资料相对较少，这也是我决定开这个专题的一个出发点，希望我能为后续投身该领域的同志们，提供一点点有价值的参考吧。  </p><p>&emsp; <strong>友情提示</strong>：该领域需要较多的精力投入才可能有高质量的产出，所以如果你暂时用不到相关知识且没有长期深入做这块的打算，不建议浪费时间在这里。<br>&emsp; 如果你有深入学习这方面的打算，或者已经在研究该领域，欢迎后续多多交流学习心得~ 这里提前谢过能指点我一二的先驱们 🙏</p><h2 id="目录一览"><a href="#目录一览" class="headerlink" title="目录一览"></a>目录一览</h2><p>&emsp; 为了大家能有一个更清晰的脉络感与更系统的整体感，我将持续的更新学习心得至该专题的目录中，作为索引，以方便大家的学习：</p><h3 id="一：《视觉开发专题》之-OpenGL-概述"><a href="#一：《视觉开发专题》之-OpenGL-概述" class="headerlink" title="一：《视觉开发专题》之 OpenGL 概述"></a>一：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2Q3ZDk3YWYyNjVkYTAzNTU1YzljYjE=" title="https://juejin.im/post/5cd7d97af265da03555c9cb1">《视觉开发专题》之 OpenGL 概述<i class="fa fa-external-link"></i></span></h3><h3 id="二：…"><a href="#二：…" class="headerlink" title="二：…"></a>二：…</h3><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><p>&emsp; “蓝宝书”、 <span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8v" title="https://learnopengl-cn.github.io/">LearnOpenGL CN<i class="fa fa-external-link"></i></span> 以及<br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsLw==" title="https://www.khronos.org/opengl/">OpenGL 官网<i class="fa fa-external-link"></i></span>  是我学习 OpenGL 的主要参考资料，我将以更容易理解的方式将所学归纳到该专题的系列文章里，并记录学习实践中遇到的一些坑点。</p><h2 id="参考资料-amp-引用"><a href="#参考资料-amp-引用" class="headerlink" title="参考资料&amp;引用"></a>参考资料&amp;引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9pdGVtLmpkLmNvbS8xMjIzNDE5Ni5odG1s" title="https://item.jd.com/12234196.html">OpenGL编程指南<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8v" title="https://learnopengl-cn.github.io/">LearnOpenGL教程<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsLw==" title="https://www.khronos.org/opengl/">OpenGL 官网&amp;文档<i class="fa fa-external-link"></i></span>  </p>]]></content>
      
      
      <categories>
          
          <category> 图形编程 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 逆向之 Cycript 高级玩法（非越狱） &amp; .cy文件的封装</title>
      <link href="/2019/04/14/iOS%20%E9%80%86%E5%90%91%E4%B9%8B%20Cycript%20%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%EF%BC%88%E9%9D%9E%E8%B6%8A%E7%8B%B1%EF%BC%89%20&amp;%20.cy%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2019/04/14/iOS%20%E9%80%86%E5%90%91%E4%B9%8B%20Cycript%20%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%EF%BC%88%E9%9D%9E%E8%B6%8A%E7%8B%B1%EF%BC%89%20&amp;%20.cy%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Cycript"><a href="#What-is-Cycript" class="headerlink" title="What is Cycript"></a>What is Cycript</h2><p>摘自<span class="exturl" data-url="aHR0cDovL3d3dy5jeWNyaXB0Lm9yZy9tYW51YWwv" title="http://www.cycript.org/manual/">官方文档<i class="fa fa-external-link"></i></span>：<br>&emsp; Cycript is a hybrid of ECMAScript some-6, Objective-C++, and Java. It is implemented as a Cycript-to-JavaScript compiler and uses (unmodified) JavaScriptCore for its virtual machine. It concentrates on providing “fluent FFI” with other languages by adopting aspects of their syntax and semantics as opposed to treating the other language as a second-class citizen.</p><p>&emsp; The primary users of Cycript are currently people who do reverse engineering work on iOS. Cycript features a highly interactive console that features live syntax highlighting and grammar-assisted tab completion, and can even be injected into a running process (similar to a debugger) using Cydia Substrate. This makes it an ideal tool for “spelunking”.</p><p>&emsp; However, Cycript was specifically designed as a programming environment and maintains very little (if any) “baggage” for this use case. Many modules from node.js can be loaded into Cycript, while it also has direct access to libraries written for Objective-C and Java. It thereby works extremely well as a scripting language.   </p><p><strong>简言之</strong>：<br>&emsp; Cycript 是由 Cydia 创始人 Saurik 推出的一款脚本语言，它混合了 ECMAScript 6.0（简称ES6，是JavaScript 语言的下一代标准）、Objective-C ++ 和 Java 的语法<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlCJUI0JUU4JUFEJUFGJUU1JTk5JUE4" title="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器<i class="fa fa-external-link"></i></span>。这意味着我们能够在一个命令中使用 OC 或者 JavaScript，甚至两者并用。Cycript 目前的主要用途是在 iOS 上进行逆向工作，使用 Cydia Substrate 可以注入正在运行的进程（类似于调试器），这使它成为“探险”的理想工具。</p><h2 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>&emsp; <span class="exturl" data-url="aHR0cDovL3d3dy5jeWNyaXB0Lm9yZy8=" title="http://www.cycript.org/">在这里<i class="fa fa-external-link"></i></span>下载 SDK到本地，为了方便每次直接可以使用，建议将可执行文件 cycript 的路径配置到环境变量中（在 .bash_profile/.zshrc [取决于你用哪个终端] 中 export 一下），打开终端，执行 <code>cycript</code> 命令：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/13/16a1550f05e36471?w=1684&amp;h=94&amp;f=png&amp;s=9569" alt></p><p>如上图所示，cy# 提示符表示进入了 JavaScript 控制台。你键入的所有内容都将由 JavaScriptCore 运行，这是 Apple 对 Safari 使用的 JavaScript 语言的实现。且在你键入时，你的命令将使用 Cycript 的词法分析器进行语法突出显，如果出现语法错误，则会出现提示。你可以使用 <code>ctrl+C</code> 取消键入，或 <code>ctrl+D</code> 退出该环境。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><h4 id="预热准备"><a href="#预热准备" class="headerlink" title="预热准备"></a>预热准备</h4><p>&emsp; 关于 Cycript 的用法，这一篇只围绕 iOS 逆向工程来展开讲述，这也是 Cycript 目前用的最广的领域。对比上一篇提到的 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzhjYTg0Y2U1MWQ0NTZmNDMxODlkYmQ=" title="https://juejin.im/post/5c8ca84ce51d456f43189dbd">LLDB<i class="fa fa-external-link"></i></span> ，Cycript 的亮点在于它可以动态注入，在运行时可以随时获取、修改程序中对象的值。而 LLDB 不管是在正向开发还是逆向工程中，它只能进行断点静态调试分析，效率相比 Cycript 有明显的不足。</p><p>&emsp; 用 Cycript 实现动态调试应用的前提，是你的应用为其开好了一个可连接的端口，鉴于越狱机并不是人人都有，此篇我主要为大家介绍<strong>非越狱环境下</strong>如何使用 Cycript 进行调试，让大家都有实操的条件。在开始使用 Cycript 之前，我们还需要准备另一个工具。</p><p>&emsp; 在过去两个多月的系列文章中，我将 iOS 的应用签名原理、自动重签名脚本以及代码注入等知识串讲了一遍，其实这些工作全都有工具帮我们集成好了，相信你也猜到了，没错，这个工具就是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fsb25lTW9ua2V5L01vbmtleURldg==" title="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev<i class="fa fa-external-link"></i></span> —- 原有 iOSOpenDev 的升级，非越狱插件开发集成神器！关于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fsb25lTW9ua2V5L01vbmtleURldi93aWtp" title="https://github.com/AloneMonkey/MonkeyDev/wiki">MonkeyDev 的安装<i class="fa fa-external-link"></i></span> 这里就不展开赘述了，安装成功后，新建一个 MonkeyApp 项目 （MonkeyDevDemo）：<br><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1ad84ee44cac9?w=1460&amp;h=1052&amp;f=png&amp;s=363350" alt></p><p>打开 MonkeyDevDemo，只需将你要调试的 ipa/app （脱壳还是必要的） 丢到新建项目的这个目录下：<br><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1ad259143bc50?w=1226&amp;h=272&amp;f=png&amp;s=79396" alt></p><p>运行项目，就可以将应用直接运行到你的真机上了：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b038dccefead?w=2916&amp;h=1412&amp;f=png&amp;s=1597261" alt></p><p>上图中，红框标注出的 <code>CYListenServer(6666);</code> 正是我们前面提到的，用 Cycript 实现动态调试应用的前提：一个可远程连接的端口号–6666，在控制台中同样可以找到打印日志：<br><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b0670779ba82?w=1992&amp;h=614&amp;f=png&amp;s=173940" alt></p><p>我相信你一定注意到了日志中的这一行：  </p><p><code>Download cycript(https://cydia.saurik.com/api/latest/3) then run: ./cycript -r 192.168.199.236:6666</code>  </p><p>&emsp; 没错，它就是在告诉你，server 端口绑定成功，终端执行 <code>./cycript -r 192.168.199.236:6666</code> 就能连接到运行中的应用了。<code>192.168.199.236</code> 是我当前手机的 ip 地址。<br>&emsp; 其实现原理，简单来讲，就是 hook 了 AppDelegate 里的 <code>application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)</code> 方法，在该方法里开启 Cycript 并绑定到6666端口。</p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>在上一篇 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzhjYTg0Y2U1MWQ0NTZmNDMxODlkYmQ=" title="https://juejin.im/post/5c8ca84ce51d456f43189dbd">LLDB<i class="fa fa-external-link"></i></span> 中推荐的插件 chisel 里，很多好用的命令在 MonkeyDev 中也都做了支持<br>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString* pvc(void);</span><br><span class="line"></span><br><span class="line">NSString* pviews(void);</span><br><span class="line"></span><br><span class="line">NSString* pactions(vm_address_t address);</span><br><span class="line"></span><br><span class="line">NSString* pblock(vm_address_t address);</span><br><span class="line"></span><br><span class="line">NSString* methods(const char * classname);</span><br><span class="line"></span><br><span class="line">NSString* ivars(vm_address_t address);</span><br><span class="line"></span><br><span class="line">NSString* choose(const char* classname);</span><br><span class="line"></span><br><span class="line">NSString* vmmap();</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b48a742c5b69?w=3356&amp;h=1678&amp;f=png&amp;s=966792" alt></p><p>赶快来试试手：找到淘宝首页底部 “淘” 按钮并将其隐藏掉：<br><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b4eba297f704?w=2866&amp;h=204&amp;f=png&amp;s=254485" alt></p><p><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b542a1bda439?w=2202&amp;h=1872&amp;f=png&amp;s=3738377" alt></p><p>是不是突然想拿微信发个 ￥0.01 的红包，然后用新学的这招操作一波：<br><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b57a9304020c?w=740&amp;h=188&amp;f=png&amp;s=96506" alt><br>emmmmmm…友情提示，登录破解的微信应用，大概率会被微信封号的，别问我怎么知道的 (&gt;_&lt;) </p><p>&emsp; 言归正传，上面列出的几个命令，基本可以满足你快速摸清一个 app 各个复杂页面的结构，同时也可以精准的定位并修改目标视图的UI。有的同学如果没接触过 Cycript ，建议先看一下 <span class="exturl" data-url="aHR0cDovL3d3dy5jeWNyaXB0Lm9yZy9tYW51YWwv" title="http://www.cycript.org/manual/">官方文档<i class="fa fa-external-link"></i></span>，熟悉下支持的语法和数据结构，多找几个小case有目的的练习，很快就能上手玩了，这对于想通过学习大厂优秀 app 的设计与实现思路的同学来说，是个不可错过的好途径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tips：  </span><br><span class="line">1. 进入了 cy# JavaScript 控制台之后，相当于处在一个进程中，因此定义的变量在进程生命周期中一直可用。</span><br><span class="line">2. #0x10c144d00 ：#+对象地址=拿到该对象</span><br></pre></td></tr></table></figure><h4 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h4><p>&emsp; 与 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzhjYTg0Y2U1MWQ0NTZmNDMxODlkYmQjaGVhZGluZy05" title="https://juejin.im/post/5c8ca84ce51d456f43189dbd#heading-9">加强版 LLDB —— 修改 .lldbinit 文件 &amp; 插件安装<i class="fa fa-external-link"></i></span> 类似，Cycript 支持加载自定义脚本，这极大的提高了它的调试效率，在前面简单使用中列出的可用快捷命令可不是 Cycript 本来就有的，而是 MonkeyDev 的作者加载了自己写的网络脚本才支持的：<br><img src="https://user-gold-cdn.xitu.io/2019/4/14/16a1b766e7f7bedc?w=2934&amp;h=846&amp;f=png&amp;s=900003" alt><br>我们可以打开该地址查看对应的<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0Fsb25lTW9ua2V5L01EQ3ljcmlwdC9tYXN0ZXIvbWQuY3k=" title="https://raw.githubusercontent.com/AloneMonkey/MDCycript/master/md.cy">.cy文件源码<i class="fa fa-external-link"></i></span>。</p><p>然后呢？然后我们也可以自己搞一份自己调试时常用的脚本，这里推荐一个小码哥写的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvZGVyTUpMZWUvbWpjcmlwdA==" title="https://github.com/CoderMJLee/mjcript">mjcript<i class="fa fa-external-link"></i></span> 。 </p><p>加载.cy脚本的方式也为你准备好了：<span class="exturl" data-url="aHR0cDovL3d3dy5hbG9uZW1vbmtleS5jb20vMjAxOC8wNC8yMC9tb25rZXlkZXYtY3ljcmlwdC8=" title="http://www.alonemonkey.com/2018/04/20/monkeydev-cycript/">通过MonkeyDev加载网络或者自己的cy脚本<i class="fa fa-external-link"></i></span>。</p><p>来感受一波自定义脚本的效率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">(function(exports) &#123;</span><br><span class="line">var invalidParamStr = &apos;Invalid parameter&apos;;</span><br><span class="line">var missingParamStr = &apos;Missing parameter&apos;;</span><br><span class="line"></span><br><span class="line">// app id</span><br><span class="line">CJAppId = [NSBundle mainBundle].bundleIdentifier;</span><br><span class="line"></span><br><span class="line">// mainBundlePath</span><br><span class="line">CJAppPath = [NSBundle mainBundle].bundlePath;</span><br><span class="line"></span><br><span class="line">// document path</span><br><span class="line">CJDocPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];</span><br><span class="line"></span><br><span class="line">// caches path</span><br><span class="line">CJCachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</span><br><span class="line"></span><br><span class="line">// 加载系统动态库</span><br><span class="line">CJLoadFramework = function(name) &#123;</span><br><span class="line">var head = &quot;/System/Library/&quot;;</span><br><span class="line">var foot = &quot;Frameworks/&quot; + name + &quot;.framework&quot;;</span><br><span class="line">var bundle = [NSBundle bundleWithPath:head + foot] || [NSBundle bundleWithPath:head + &quot;Private&quot; + foot];</span><br><span class="line">  [bundle load];</span><br><span class="line">  return bundle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// keyWindow</span><br><span class="line">CJKeyWin = function() &#123;</span><br><span class="line">return UIApp.keyWindow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 根控制器</span><br><span class="line">CJRootVc =  function() &#123;</span><br><span class="line">return UIApp.keyWindow.rootViewController;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 找到显示在最前面的控制器</span><br><span class="line">var _CJFrontVc = function(vc) &#123;</span><br><span class="line">if (vc.presentedViewController) &#123;</span><br><span class="line">        return _CJFrontVc(vc.presentedViewController);</span><br><span class="line">    &#125;else if ([vc isKindOfClass:[UITabBarController class]]) &#123;</span><br><span class="line">        return _CJFrontVc(vc.selectedViewController);</span><br><span class="line">    &#125; else if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">        return _CJFrontVc(vc.visibleViewController);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    var count = vc.childViewControllers.count;</span><br><span class="line">    for (var i = count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    var childVc = vc.childViewControllers[i];</span><br><span class="line">    if (childVc &amp;&amp; childVc.view.window) &#123;</span><br><span class="line">    vc = _CJFrontVc(childVc);</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        return vc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CJFrontVc = function() &#123;</span><br><span class="line">return _CJFrontVc(UIApp.keyWindow.rootViewController);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 递归打印UIViewController view的层级结构</span><br><span class="line">CJVcSubviews = function(vc) &#123;</span><br><span class="line">if (![vc isKindOfClass:[UIViewController class]]) throw new Error(invalidParamStr);</span><br><span class="line">return vc.view.recursiveDescription().toString(); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 递归打印最上层UIViewController view的层级结构</span><br><span class="line">CJFrontVcSubViews = function() &#123;</span><br><span class="line">return CJVcSubviews(_CJFrontVc(UIApp.keyWindow.rootViewController));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 获取按钮绑定的所有TouchUpInside事件的方法名</span><br><span class="line">CJBtnTouchUpEvent = function(btn) &#123;</span><br><span class="line">var events = [];</span><br><span class="line">var allTargets = btn.allTargets().allObjects()</span><br><span class="line">var count = allTargets.count;</span><br><span class="line">    for (var i = count - 1; i &gt;= 0; i--) &#123; </span><br><span class="line">    if (btn != allTargets[i]) &#123;</span><br><span class="line">    var e = [btn actionsForTarget:allTargets[i] forControlEvent:UIControlEventTouchUpInside];</span><br><span class="line">    events.push(e);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   return events;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// CG函数</span><br><span class="line">CJPointMake = function(x, y) &#123;</span><br><span class="line">return &#123;0 : x, 1 : y&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CJSizeMake = function(w, h) &#123;</span><br><span class="line">return &#123;0 : w, 1 : h&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CJRectMake = function(x, y, w, h) &#123;</span><br><span class="line">return &#123;0 : CJPointMake(x, y), 1 : CJSizeMake(w, h)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 递归打印controller的层级结构</span><br><span class="line">CJChildVcs = function(vc) &#123;</span><br><span class="line">if (![vc isKindOfClass:[UIViewController class]]) throw new Error(invalidParamStr);</span><br><span class="line">return [vc _printHierarchy].toString();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 递归打印view的层级结构</span><br><span class="line">CJSubviews = function(view) &#123;</span><br><span class="line">if (![view isKindOfClass:[UIView class]]) throw new Error(invalidParamStr);</span><br><span class="line">return view.recursiveDescription().toString(); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断是否为字符串 &quot;str&quot; @&quot;str&quot;</span><br><span class="line">CJIsString = function(str) &#123;</span><br><span class="line">return typeof str == &apos;string&apos; || str instanceof String;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断是否为数组 []、@[]</span><br><span class="line">CJIsArray = function(arr) &#123;</span><br><span class="line">return arr instanceof Array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 判断num是否为数字</span><br><span class="line">CJIsNumber = function(num) &#123;</span><br><span class="line">return typeof num == &apos;number&apos; || num instanceof Number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var _CJClass = function(className) &#123;</span><br><span class="line">if (!className) throw new Error(missingParamStr);</span><br><span class="line">if (CJIsString(className)) &#123;</span><br><span class="line">return NSClassFromString(className);</span><br><span class="line">&#125; </span><br><span class="line">if (!className) throw new Error(invalidParamStr);</span><br><span class="line">// 对象或者类</span><br><span class="line">return className.class();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的子类</span><br><span class="line">CJSubclasses = function(className, reg) &#123;</span><br><span class="line">className = _CJClass(className);</span><br><span class="line"></span><br><span class="line">return [c for each (c in ObjectiveC.classes) </span><br><span class="line">if (c != className </span><br><span class="line">&amp;&amp; class_getSuperclass(c) </span><br><span class="line">&amp;&amp; [c isSubclassOfClass:className] </span><br><span class="line">&amp;&amp; (!reg || reg.test(c)))</span><br><span class="line">];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的方法</span><br><span class="line">var _CJGetMethods = function(className, reg, clazz) &#123;</span><br><span class="line">className = _CJClass(className);</span><br><span class="line"></span><br><span class="line">var count = new new Type(&apos;I&apos;);</span><br><span class="line">var classObj = clazz ? className.constructor : className;</span><br><span class="line">var methodList = class_copyMethodList(classObj, count);</span><br><span class="line">var methodsArray = [];</span><br><span class="line">var methodNamesArray = [];</span><br><span class="line">for(var i = 0; i &lt; *count; i++) &#123;</span><br><span class="line">var method = methodList[i];</span><br><span class="line">var selector = method_getName(method);</span><br><span class="line">var name = sel_getName(selector);</span><br><span class="line">if (reg &amp;&amp; !reg.test(name)) continue;</span><br><span class="line">methodsArray.push(&#123;</span><br><span class="line">selector : selector, </span><br><span class="line">type : method_getTypeEncoding(method)</span><br><span class="line">&#125;);</span><br><span class="line">methodNamesArray.push(name);</span><br><span class="line">&#125;</span><br><span class="line">free(methodList);</span><br><span class="line">return [methodsArray, methodNamesArray];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var _CJMethods = function(className, reg, clazz) &#123;</span><br><span class="line">return _CJGetMethods(className, reg, clazz)[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的方法名字</span><br><span class="line">var _CJMethodNames = function(className, reg, clazz) &#123;</span><br><span class="line">return _CJGetMethods(className, reg, clazz)[1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的对象方法</span><br><span class="line">CJInstanceMethods = function(className, reg) &#123;</span><br><span class="line">return _CJMethods(className, reg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的对象方法名字</span><br><span class="line">CJInstanceMethodNames = function(className, reg) &#123;</span><br><span class="line">return _CJMethodNames(className, reg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的类方法</span><br><span class="line">CJClassMethods = function(className, reg) &#123;</span><br><span class="line">return _CJMethods(className, reg, true);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的类方法名字</span><br><span class="line">CJClassMethodNames = function(className, reg) &#123;</span><br><span class="line">return _CJMethodNames(className, reg, true);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的成员变量</span><br><span class="line">CJIvars = function(obj, reg)&#123;</span><br><span class="line">if (!obj) throw new Error(missingParamStr);</span><br><span class="line">var x = &#123;&#125;; </span><br><span class="line">for(var i in *obj) &#123; </span><br><span class="line">try &#123; </span><br><span class="line">var value = (*obj)[i];</span><br><span class="line">if (reg &amp;&amp; !reg.test(i) &amp;&amp; !reg.test(value)) continue;</span><br><span class="line">x[i] = value; </span><br><span class="line">&#125; catch(e)&#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line">return x; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 打印所有的成员变量名字</span><br><span class="line">CJIvarNames = function(obj, reg) &#123;</span><br><span class="line">if (!obj) throw new Error(missingParamStr);</span><br><span class="line">var array = [];</span><br><span class="line">for(var name in *obj) &#123; </span><br><span class="line">if (reg &amp;&amp; !reg.test(name)) continue;</span><br><span class="line">array.push(name);</span><br><span class="line">&#125;</span><br><span class="line">return array;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)(exports);</span><br></pre></td></tr></table></figure><p>只要你想，只要你能，更多姿势，等你解锁。</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>&emsp; 无使用场景的学习多半都是在浪费时间，不经常使用的知识也无法产生价值。Cycript 也不例外，如果仅仅是出于好奇，花了两个小时玩了一下下，然后从此别过，其实意义真的不大。有些同学觉得广泛涉猎，在面试的时候可以夸夸其谈，能增加一点“大佬”感，我个人是不认同的，稍微深入一点的问题你就说不上来或者干脆不懂装懂反而会适得其反。所以个人还是建议，既然学了一个东西，就尽力学的深入一点，并在工作中不断思考，如何利用已学知识去提高效率。Cycript 除了在逆向工程中， 在正向开发和日常学习中，依然非常好用。</p><p>愿你有所收获~</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDB 知多少</title>
      <link href="/2019/03/23/LLDB%20%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
      <url>/2019/03/23/LLDB%20%E7%9F%A5%E5%A4%9A%E5%B0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="重识-LLDB"><a href="#重识-LLDB" class="headerlink" title="重识 LLDB"></a>重识 LLDB</h2><h3 id="LLDB-是什么？"><a href="#LLDB-是什么？" class="headerlink" title="LLDB 是什么？"></a>LLDB 是什么？</h3><p>&emsp;“如果调试是删除 bug 的过程，那么编程就是引入 bug 的过程。”（Edsger W. Dijkstra）</p><p>&emsp;对于苹果开发者而言，LLDB 是无人不知的调试工具，然而此知非彼知，相信有相当规模的开发者对 LLDB 的了解仍然停留于几个基础命令的使用，今天让我们来重新认识一下既熟悉又陌生的 LLDB，看看它那些你不曾用过的强大功能，以及如何提高我们的开发效率。  </p><p>&emsp;开始把玩其功能之前，先搞清楚 LLDB 是什么，简言之，LLDB 是一个有着 REPL 的特性和 C++ 、Python 插件的开源调试器。</p><p>&emsp;LLDB is a next generation, high-performance debugger. It is built as a set of reusable components which highly leverage existing libraries in the larger LLVM Project, such as the Clang expression parser and <span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnLw==" title="http://llvm.org/">LLVM<i class="fa fa-external-link"></i></span> disassembler.<br>&emsp;LLDB is the default debugger in Xcode on Mac OS X and supports debugging C, Objective-C and C++ on the desktop and iOS devices and simulator.  </p><p>&emsp;以上摘自官方文档中的一段简短的介绍，更多相关信息请参阅 LLDB <span class="exturl" data-url="aHR0cDovL2xsZGIubGx2bS5vcmcvaW5kZXguaHRtbA==" title="http://lldb.llvm.org/index.html">官方文档<i class="fa fa-external-link"></i></span>。</p><h3 id="LLDB-命令结构"><a href="#LLDB-命令结构" class="headerlink" title="LLDB 命令结构"></a>LLDB 命令结构</h3><p>&emsp;知道了 LLDB 是什么，还要了解其命令结构及语法，这样才能告别死记命令，开启压榨 LLDB 之路了。LLDB 通用结构的形式如下：  </p><p><code>&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</code>  </p><p>其中：</p><ul><li>command、subcommand：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。</li><li>action：命令操作，想在前面的命令序列的上下文中执行的一些操作。</li><li>options：命令选项，行为修改器(action modifiers)。通常带有一些值。</li><li>argument：命令参数，根据使用的命令的上下文来表示各种不同的东西。</li><li>[]：表示命令是可选的，可以有也可以没有。  </li></ul><p>举个例子：</p><p>命令：<code>breakpoint set -n main</code> 对应到上面的语法就是：</p><ul><li>command：breakpoint 断点命令</li><li>action：set 设置断点</li><li>option：-n 表根据方法 name 设置断点</li><li>arguement：mian 表示方法名为 mian</li></ul><p>关于<strong>原始命令</strong>：</p><p>&emsp;LLDB支持不带命令选项的原始命令，原始命令会将命令后面的所有东西当做参数(arguement)处理。但很多原始命令也可以带命令选项，当你使用命令选项的时候，需要在命令选项后面加 <code>--</code> 区分命令选项和参数。<br>&emsp;如：<code>expression</code> （就是 <code>p</code>/<code>print</code>/<code>call</code>）、<code>expression -o</code>（就是 <code>po</code>），打印一个<code>UIView</code>对象地址：<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a926c79ac2fad?w=970&amp;h=205&amp;f=png&amp;s=55903" alt><br>&emsp;前者是计算其地址的值，后者调用了对象的 description 方法，其中体现了唯一匹配原则：假如根据前n个字母已经能唯一匹配到某个命令，则只写前n个字母等效于写下完整的命令。再用设置断点的命令举例，下面两条命令等效：<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a95fec62b6dc5?w=677&amp;h=67&amp;f=png&amp;s=14387" alt><br>&emsp;更多命令结构的介绍及用法，请参考 <span class="exturl" data-url="aHR0cDovL2xsZGIubGx2bS5vcmcvdHV0b3JpYWwuaHRtbA==" title="http://lldb.llvm.org/tutorial.html">LLDB 入门<i class="fa fa-external-link"></i></span>。接下来介绍点 LLDB 最实用又最容易被忽略的用法。</p><hr><h2 id="LLDB-常用命令总结"><a href="#LLDB-常用命令总结" class="headerlink" title="LLDB 常用命令总结"></a>LLDB 常用命令总结</h2><h3 id="辅助记忆：apropos"><a href="#辅助记忆：apropos" class="headerlink" title="辅助记忆：apropos"></a>辅助记忆：apropos</h3><p>&emsp;当我们并不能完全记得某个命令的时候，使用 <strong>apropos</strong> 通过命令中的某个关键字就可以找到所有相关的命令信息。<br>比如: 我们想使用stop-hook的命令，但是已经不记得stop-hook命令是啥样了：<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9a93fb2e4469?w=992&amp;h=276&amp;f=png&amp;s=72149" alt><br>实在记不起来也不要慌，这里有 <span class="exturl" data-url="aHR0cHM6Ly9sbGRiLmxsdm0ub3JnL2xsZGItZ2RiLmh0bWw=" title="https://lldb.llvm.org/lldb-gdb.html">命令list<i class="fa fa-external-link"></i></span>。</p><h3 id="一-断点设置"><a href="#一-断点设置" class="headerlink" title="一.断点设置"></a>一.断点设置</h3><p>&emsp;关于断点设置，多数人都习惯用图形界面去做，但在调试中有些场景仅仅靠图形界面还是不够的，比如：如何通过断点实现类似 KVO 那样对成员变量变化的监听呢？（别跟我说你要加代码重写set方法…即使这样也不靠谱）。下面一一罗列那些好用的断点命令：</p><ol><li>breakpoint list：查看所有断点列表</li><li>breakpoint delete：删除所有断点（可跟组号删除指定组）</li><li>breakpoint disable/enable：禁用 启用指定断点</li><li>breakpoint set -r some：遍历整个项目中包含 some 这个字符的所有方法并设置断点</li><li>breakpoint 支持按文件名、函数名、行数、正则等各种条件筛选设置断点，请结合语法并参考官方文档</li><li>watchpoint set expression 0x10cc64d50：在内存中为地址为0x10cc64d50的对象设置内存断点</li><li>watchpoint set variable xxoo：为当前对象的变量 xxoo 设置内存断点</li><li>target stop-hook add -o “frame variable”：添加每次程序 stop 时都希望执行的命令：frame variable（打印当前栈内的所有变量）</li><li>target stop-hook、watchpoint 的增删改查命令与 breakpoint 的基本相同</li><li>更多变态断点玩法需自定义插件支持，迫不及待的你请快进此文 》》》</li></ol><h3 id="二-流程控制"><a href="#二-流程控制" class="headerlink" title="二.流程控制"></a>二.流程控制</h3><p>这两幅图你一定不陌生：</p><ol><li>图一<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9c232e8133fd?w=838&amp;h=65&amp;f=png&amp;s=17763" alt></li><li>图二<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9c1cf046cc81?w=712&amp;h=53&amp;f=png&amp;s=13168" alt></li></ol><ul><li>第一个按钮：continue/c 继续执行</li><li>第二个按钮：<ul><li>图一： thread step-over/next/n 当前线程下一步（以一个完整子函数为一步）</li><li>图二：  thread step-inst-over/ni 当前线程下一步（以一个汇编函数为一步）</li></ul></li><li>第三个按钮：<ul><li>图一： thread step-in/step/s 当前线程下一步（遇到子函数就进入并且继续单步执行）</li><li>图二： thread step-inst-over/si 当前线程下一步（遇到汇编函数就进入并且继续单步执行汇编指令）</li></ul></li><li>第四个按钮：thread step-out/finish 退出当前帧栈</li></ul><p>其他命令：  </p><ul><li>thread return：它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离次函数、伪造返回值的方式。</li></ul><h3 id="三-可执行文件-amp-共享库查询命令"><a href="#三-可执行文件-amp-共享库查询命令" class="headerlink" title="三.可执行文件&amp;共享库查询命令"></a>三.可执行文件&amp;共享库查询命令</h3><p>这些命令在逆向及定位错误时使用频率非常高。</p><ol><li>image list：列出主要的可执行文件和所有依赖的共享库。</li><li>image lookup –address 0x1ec4：在可执行文件或任何共享库中查找原始地址信息。</li><li>image lookup -v –address 0x1ec4：查找完整的源代码行信息。</li><li>image lookup –type NSString：根据名称查找对应（NSString）类型的信息。</li></ol><h3 id="四-其他常用命令模板"><a href="#四-其他常用命令模板" class="headerlink" title="四.其他常用命令模板"></a>四.其他常用命令模板</h3><ol><li>register read：显示当前线程的通用寄存器。</li><li>register write rax 123：将一个新的十进制值“123”写入当前线程寄存器“rax”。</li><li>memory read –size 4 –format x –count 4 0xbffff3c0：从地址0xbffff3c0读取内存，并显示4个十六进制uint32_t值。</li></ol><h2 id="加强版-LLDB-——-修改-lldbinit-文件-amp-插件安装"><a href="#加强版-LLDB-——-修改-lldbinit-文件-amp-插件安装" class="headerlink" title="加强版 LLDB —— 修改 .lldbinit 文件 &amp; 插件安装"></a>加强版 LLDB —— 修改 <code>.lldbinit</code> 文件 &amp; 插件安装</h2><p>&emsp;前面所列的命令在 <span class="exturl" data-url="aHR0cHM6Ly9sbGRiLmxsdm0ub3JnL2xsZGItZ2RiLmh0bWw=" title="https://lldb.llvm.org/lldb-gdb.html">这里<i class="fa fa-external-link"></i></span> 都能找到官方说明，更多命令用法有兴趣的建议自己去细细探索，接下来我们将站在巨人的肩膀上，用高手们专门为 LLDB 写的插件去深入挖掘它的潜力。  </p><ol><li><p><strong>推荐插件一</strong>： facebook 开源的 LLDB 插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NoaXNlbA==" title="https://github.com/facebook/chisel">chisel<i class="fa fa-external-link"></i></span></p><p> <code>brew install chisel</code> 的安装过程这里就不赘述了，安装成功后，在~/目录下的 <code>.lldbinit</code> 文件中引入对应文件路径，增加一行：<code>command script import /usr/local/opt/chisel/libexec/fblldb.py</code> 后保存， 重启 Xcode即可使用。它提供的快捷 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NoaXNlbC93aWtp" title="https://github.com/facebook/chisel/wiki">命令清单及说明<i class="fa fa-external-link"></i></span> 这里也不赘述了。截个图感受下它的强大吧：<br><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aa02fe152b579?w=967&amp;h=697&amp;f=png&amp;s=160330" alt></p></li><li><p><strong>推荐插件二</strong>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RlcmVrU2VsYW5kZXIvTExEQg==" title="https://github.com/DerekSelander/LLDB">DerekSelander/LLDB<i class="fa fa-external-link"></i></span></p><p> 该插件与 chisel 都是用 Python 写的，其安装需要手动下载仓库，然后将仓库中 <code>dslldb.py</code> 文件的路径用与上述同样的方式添加到  <code>.lldbinit</code> 中，具体用法也很简单粗暴，就不在这粘贴了，请至 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RlcmVrU2VsYW5kZXIvTExEQi9ibG9iL21hc3Rlci9SRUFETUUubWQ=" title="https://github.com/DerekSelander/LLDB/blob/master/README.md">README<i class="fa fa-external-link"></i></span> 领略。</p></li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>&emsp;看到这，你收获的只有暂时记忆，其实等于毫无所获…而且还浪费了宝贵的几分钟，这也是我极不希望看到的，而避免其成为事实的唯一方式就是，请你打开 Xcode，运行一个项目，参照着文中涉及到的说明文档，试着敲一敲每个命令，体会一下它们的用法与区别。最后，为你的 LLDB 配好插件，去感受它的蜕变，相信我，你的开发效率提升的可不止一点点。学习是一种能力，拒绝操作手册式灌输，分享者多半是在总结学习收获时为读者提供一些思路或方向，这也是我为你保留一丝探索余地的初衷，愿你有所收获。</p><p>&emsp;水平有限，请大神多多指正。下篇再会~</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> LLDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝做焦虑贩卖者的韭菜</title>
      <link href="/2019/03/16/%E6%8B%92%E7%BB%9D%E5%81%9A%E7%84%A6%E8%99%91%E8%B4%A9%E5%8D%96%E8%80%85%E7%9A%84%E9%9F%AD%E8%8F%9C/"/>
      <url>/2019/03/16/%E6%8B%92%E7%BB%9D%E5%81%9A%E7%84%A6%E8%99%91%E8%B4%A9%E5%8D%96%E8%80%85%E7%9A%84%E9%9F%AD%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="多数人的现状"><a href="#多数人的现状" class="headerlink" title="多数人的现状"></a>多数人的现状</h3><p>&emsp; 无论你出入职场，还是置身亲友，不管你是大龄未婚，还是已为人父母，纵然你已小有成就，亦或名利双收，我依然深信总有那么一群不满现状的人，在各种圈子里、角色下、欲望中，被不同的焦虑环绕着，看看身边年龄相仿的同事、亲友的现状，一切都不言自明。写这篇文章的初衷，是希望我们都能正确的看待焦虑，同时传递给你两个信息：1.不做勤劳的懒惰者；2.你并不孤单，也从未丧失机会。</p><p>&emsp; 30左右的年龄（中年危机），在一二线城市没房又没成家（无可增长资产，且未来仍有大笔支出），资本市场持续降温（虽然这是短期的转折，但历史进化永远都是在淘汰弱者），新技术、新概念更新速度越来越快（吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！）……这是目前互联网从业者（其实远不止）的大部分现状。这一现状无疑让越来越多的人感到焦虑，特别是对自己有更高期望而瓶颈很难突破的人。当然不排除有无论世界怎么变都无知无觉的人，他们不在我们今天讨论的范畴。</p><p>&emsp; 基于上述普遍存在的现状，越来越多的人从中发现了商机：1、知识付费；2、毒鸡汤抢流量。首先声明一点，我是知识付费的拥护者，同时也是受益者。但每当某一领域的需求增长过快时，都难免有一群趁机谋取利益的水军混入其中，良莠不齐，使人们获取有价值信息的成本不断提高。从前几年一度火爆的培训班，到现在线上平台的付费专栏、直播授课，交学费时无不吹破牛皮、信誓旦旦，到最后学无所成的人比比皆是。这究竟是授课的机构和讲师水平的问题，还是学习者自身的学习能力不够或者半途而废造成的呢？我觉得都有问题。毒鸡汤类的公众号、自媒体，更是无处不在的收割着人们的注意力和时间。而被毒鸡汤淹没，只能承认更多是因为个人认知水平决定了识别能力。</p><p>&emsp; 如果你认为贩卖焦虑只限于上述商业从事者，那说明你还未曾就此深入的思考过。在我看来，一切利用人们焦虑情绪去做更利于自己事情的人，都是焦虑贩卖者。更有甚者，先诱导人产生焦虑再加以利用。如果你仔细观察，这样的人其实你身边也大有人在。包括很多亲友甚至都在无意识的为你增加焦虑，然后促使你去做什么什么…这里就不区分主观意识的好坏了。总之，我们自己要有足够强的自我掌控力和辨别能力，才能尽可能避免自己和身边的人成为被别人利用情绪进而操纵行为的人。拒绝做炮灰，主导自己命运的方向。</p><h3 id="我的挣扎历程"><a href="#我的挣扎历程" class="headerlink" title="我的挣扎历程"></a>我的挣扎历程</h3><p>&emsp; 我就此现状分享下我的一点心得吧，同时也很想听到你们对自我成长的见解和当前形势的看法。</p><p>&emsp; 显然我的现状仍属上述之列（没办法，我开窍晚了），所以曾经我也焦虑过，也被收过智商税，但好在已于一年前想清楚了自己该做什么、想要什么，所以现在的状态总体还不错 —— 每一天都能真切的感到比昨天进步了，无论是专业技能上，还是其他领域的知识，都在不断的添砖加瓦，逐渐的自成体系。如果你也有这种感受，我相信你也早跟焦虑彻底说再见了。至于如何彻底走出焦虑的阴影，找到自己的方向和目标，我仔细回想了那段时间自己的心路历程，大致总结如下：</p><h4 id="刨根问底"><a href="#刨根问底" class="headerlink" title="刨根问底"></a>刨根问底</h4><ol><li><p>想明白焦虑是什么？</p><p> 我的理解：<strong>对现状的不满 + 改变现状时的无力/乏力感 + 对未来的不确定 = 焦虑</strong></p></li><li><p>焦虑从何而来？</p><p> 结合前一点，焦虑主要有以下来源：</p><ol><li>职业发展的迷茫与无助</li><li>成长速度过慢甚至停止</li><li>人与人之间横向的对比</li><li>距离自我期望差距太大</li><li>人生大事至今毫无头绪</li><li>科技进步社会变迁加速</li></ol></li><li><p>如何彻底根治焦虑？</p><p> 同样结合上面的分析，对症下药：</p><ol><li>人的精力是有限的，无所不能的天才确实存在，但请相信我，我们都不是。有限的精力一定要花在最有用、长期收益最大的事情上，别想着什么都想学，静下心来分析，找准你所在的领域里，在可以预见的未来某一个不可或缺的方向，花几年时间把它做到极致。（不要抱怨工作太忙没时间想，没时间做，至少你永远都有选择的权利）</li><li>学习一定是有方法可循的，最好的方式就是尽可能找到你能接触到的行业大牛（一定要是能说实话的人），实在没机会就关注他们的动态、博客、心得，他们之所以能走的比你快，一定是有很多可取之处的，思考方式、对新事物的态度、乐于分享和总结的精神等等，找到属于你的标杆（不需要很多，一两个足够），照着做就是了，对了，请忘记“速成”这个词。最好的方法一定来自不断的实践与总结，绝不是简单的模仿。</li><li>你会经常发现，哇，这小子比我小好几岁，却样样比我优秀！这其实是个不值得有任何感叹的事实，《师说》曾说：“生乎吾后，其闻道也亦先乎吾，吾从而师之”、“闻道有先后，术业有专攻”。人生来先天条件各不相同，即使先天条件不如你的后来比你强了，也没什么可比性。因为你不仅要承认努力很重要，运气也很重要。而决定运气的是我们对这个世界的态度。接纳不够好的自己，做好自己该做的，优秀的人是用来学习借鉴的，而不是衬托自己落魄的。</li><li>合理的目标是前提，否则这无异于给自己一个必败的残局和自我否定的恶性循环。人的幸福感很大程度上来源于自恋的感觉被满足，无论是恋爱还是交朋友，都是因为他们认可你，满足了你的自恋情绪，所以他们才能激发你的潜能。同样的，合理的目标是最好的自我鼓励方式，阶段性的达成目标，才能形成自我认可、持续进步、不断缩小与更高期望之间差距的正向循环。</li><li>大龄单身青年随处可见，第一个原因，人所受教育的程度与为繁衍后代（完成任务）而结婚的接受度呈明显负相关，也就是说，不是你一个人不想将就，是都不想将就。第二个原因，社会的高速发展注定了年轻一代的高压状态，而且该状态在可预见的未来会一直持续，这种状态决定了接触到靠谱异性圈子的场景越来越少，这两点也是高等教育普及以来人口生育率一路下滑的真相。第三个原因，你不够主动，其实还是有很多合适的人在等你主动，不要做个玻璃心，不试试怎么知道呢？偷偷告诉你，我就是这么成功的。</li><li>不管科技如何发达，社会如何变革，既然追不上变化那就别追了，倒不如换个角度想想什么是一成不变的。这之前，先区分一下两个词，趋势和潮流。乍一看以为是同义词，其实很多时候是截然相反的两个东西，但它们又互相作用，类似海洋深处的暗流涌动与我们看得到的狂风骇浪的关系。暗流就是趋势，它是由人类共同体决定的大方向，其力量之大往往是不可抗力，且需要较长的时间才能逐渐显现出来。而潮流则瞬息万变，无法捕捉，但它却又是暗流之上的具体体现。这跟我们想说的有什么关系呢？简单来说，如果你一直忙于追随潮流、赶热门、学热点，就像是在玩冲浪一样，即使短时间内你借着几个浪头获得了升迁加薪的机会，多半也是昙花一现，结局都只会被下一个风头无情的拍入海底。如果你深入观察分析行业内的顶尖人士，你会发现他们都不是全能型的，且他们都具有以不变应万变的本领，因为他们抓住了没变的东西，预测到了未来的趋势。那到底什么是不变的，又如何做出预测的呢？通过不断观察、学习和验证，我得出以下两点：<ul><li>一，人的基本需求和本性。根据这一点（前提是你对人性和心理学有一定的研究），对未来的预测也比较简单粗暴：关注新的科学和技术，思考科技如何更好的满足人的基本需求和本性：它们有哪些将要落地或者已经落地但需求远大于供给的场景。</li><li>二，社会的财富分配规律。无论社会财富积累有多丰裕，穷人所占的比例似乎并无变化，即使人均收入不断增加，那也只是富人拉升平均数的假象。这侧面反映出真正不向命运低头，愿意为改变现状付出代价的人并不多。无论是环境影响还是趋利避害的本能反应，动物都是愿意呆在自己舒适区的，所以，如果你能离开自己的舒适区，把人生当做一场马拉松，你一直都大有机会。但，请给自己成长的时间，相信积累的力量。</li></ul></li></ol></li></ol><h4 id="回到现实"><a href="#回到现实" class="headerlink" title="回到现实"></a>回到现实</h4><p>&emsp; 无论道理理解的有多透彻，但人终究还是要活在现实里的，睡觉之前满腔热血，一觉醒来还懒床的人太多了，不差你一个。如何将所学致于实践，这才是拉开人与人之间差距的决定性因素，一提到实干，就不禁想到鸡汤…关于毅力、执行力这一类的书籍和方法论我个人都觉得不值一提，甚至全都是伪命题。我觉得任何一件事能不能做成（别拿与自身不切实际的事钻牛角尖），唯一的决定性因素就是：你到底有多想要。对，任何一件事的失败都可以归结于这一点：你不够想要它。如果这件事对你而言没得选，无可替代，优先级满星，你还需要毅力？还需要想办法提高执行力？怕是不让你做你都要拼命抵抗的吧，所以请为每一个目标赋予其重大到不得不做的意义。而仅次于此的因素，就是做什么，怎么做，关于这一点，前面列出的原因和方案中已经足够详细了。不做懒惰的勤奋者，就是要重视方法和效率，拒绝埋头蛮干。选对方向，用正确的方式，做正确的事，剩下的交给时间。</p><p>&emsp; 以上纯属我个人关于如何摆脱焦虑的一些心得和怎样踏实的做好现在的一些思考，不对任何结论的对错及其结果负责，但也希望能为你提供一些可参考之处，当然我也欣然接受任何不同的价值观和看法，欢迎交流。</p><h3 id="总结下我想说的话"><a href="#总结下我想说的话" class="headerlink" title="总结下我想说的话"></a>总结下我想说的话</h3><ol><li>付费学习是件好事，前提是你并非出于缓解焦虑而付费，而是很清楚你想做什么。</li><li>如果你真的决定要变得优秀，请不要着眼于钱，成长若是成真，钱只是顺便的东西。</li><li>不要急躁，静下来，好好提升自己的学习能力，认知能力，才能更好的筛选有价值的东西。</li><li>别怕你对自己的高要求会让你变得不合群，他们只是害怕你成长的太快而已，你也从未孤单过。</li><li>如果你对自己没要求，就开开心的过好每一天，切莫怨天尤人，抱怨是最要不得的情绪，那只会体现自己的无能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
          <category> 反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fishhook使用场景&amp;源码分析</title>
      <link href="/2019/03/08/fishhook%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&amp;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/08/fishhook%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&amp;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="不做伪学习者"><a href="#不做伪学习者" class="headerlink" title="不做伪学习者"></a>不做伪学习者</h2><p>&emsp;上一篇我们一起分析了 <a href="https://enjoycoding007.github.io/2019/03/04/fishhook%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/">fishhook的实现原理</a>，但很多东西如果我们仅仅知道原理，其实距离真正吸收它并将其转化成自己的生产力还有很长的路。你得弄清楚别人是怎么利用这个原理去解决问题的，还要借鉴别人的设计思想，再结合我们自己的思考不断地实践和总结，才能真正让知识成为自己的生产力。  </p><p>&emsp;话不多说，进入今天的第一个正题。</p><h2 id="fishhook-使用场景"><a href="#fishhook-使用场景" class="headerlink" title="fishhook 使用场景"></a>fishhook 使用场景</h2><p>&emsp;在 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzdiNDM5NzZmYjlhMDRhMDU0MDYzMTI=" title="https://juejin.im/post/5c7b43976fb9a04a05406312">上一篇<i class="fa fa-external-link"></i></span> 里已经为大家演示了它的基本用法，使用很简单，这里就不展开了。它的使用场景正如其名: fishhook，主要用在安全防护领域。当然，大神级的逆向与安全防护专家咱们先不谈，那个级别的高手我相信也不会看到这篇文章，天下没有绝对的安全，黑与白永远都在博弈，所以希望大家不要钻牛角尖，至少咱们不能写出让菜鸟逆向就能轻松搞定的应用对吧？当然，后面咱们也会学习静态分析和汇编的知识，掌握更高级的逆向和防护技能，那都是打好基础的后话了。今天咱们的重点是源码分析，顺便温习下 c 的数据结构。</p><p>下面先来了解一下用 fishhook 防 HOOK 的基本思路：</p><ol><li>在基础的动态调试逆向中，最常见的就是定位到目标方法后，通过 runtime 中的几种方法交换方式，实现代码注入的目的。为你准备好了相关的文章：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzYxNjU1MmYyNjVkYTJkZDUzZmE0ZTc=" title="https://juejin.im/post/5c616552f265da2dd53fa4e7">iOS代码注入+HOOK微信登录<i class="fa fa-external-link"></i></span></li><li>既然 fishhook 可以拦截系统外部的 C 函数，那自然就可以 HOOK 到 runtime 库中的所有方法。</li><li>那我们就将所有可能用来篡改我们 OC 方法实现的 runtime API，都用 fishhook 拦截掉，使其无法用代码注入的方式成功 HOOK。</li></ol><p>思路理清了，撸起袖子开始干。</p><ul><li>为了方便演示，这里直接搞了一个分类，将ViewController的 实例方法 <code>viewDidAppear:</code> 用 <code>method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</code> 的方式与 <code>my_viewDidAppear:</code> 交换了实现，上代码：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/169590476f100040?w=2164&amp;h=858&amp;f=png&amp;s=667798" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/8/16959050bcc38a33?w=2422&amp;h=800&amp;f=png&amp;s=683109" alt><br>这时我们程序跑起来就可以看到如下输出：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695c73609b92111?w=2838&amp;h=506&amp;f=png&amp;s=258672" alt></li><li>为了阻止其完成方法交换，我们要 hook <code>method_exchangeImplementations</code> 方法，拖入 fishhook 源文件，再添加一个分类并写好 hook <code>method_exchangeImplementations</code> 的代码：（如果成功 hook 了 <code>method_exchangeImplementations</code> ，那别人调用该方法时会进入我们的 <code>myExchange</code> ，然后顺便又把 <code>NSLog</code> hook 了一下，不要被这个绕晕了 😜）<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/169591c9339cf9b9?w=1990&amp;h=1922&amp;f=png&amp;s=576134" alt><br>再次 Run 起来，咦？肿么肥四？你会发现 <code>method_exchangeImplementations</code> 并没有 HOOK 成功， <code>viewDidAppear:</code> 依然被篡改了实现，问题出在哪了呢？  </li></ul><p>&emsp;对，聪明的你一定发现了问题所在：<strong>是代码执行顺序的问题</strong></p><p>&emsp;经过实践，我发现项目里参与编译的文件顺序就是其编译后被加载时的载入顺序（暂未找到官方的编译顺序说明，还请有研究的大佬指点），即此时 <code>ViewController+HOOKTest</code> 的 <code>load</code> 方法会早于 <code>ViewController+FishHook</code> 的 <code>load</code> 调用，所以 <code>method_exchangeImplementations</code> 的实现被我们 HOOK 发生在 <code>viewDidAppear:</code> 被别人交换之后，从而导致防护的失败：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695922be53eb4e4?w=1782&amp;h=422&amp;f=png&amp;s=104432" alt><br>验证一下我们的想法：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/169593af27a193ea?w=2262&amp;h=1132&amp;f=png&amp;s=311764" alt></p><p>&emsp;如上图所示，在调整了编译文件的顺序之后成功 HOOK 到了 <code>method_exchangeImplementations</code> 的调用，但实际开发中我们不可能采用这么笨的方法，也不可能通过这种方式决定文件的载入顺序，因此我们要想办法保证 fishhook 的代码必须最先执行才行。  </p><p>&emsp;那如何做到呢？由此前的 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzcyNzI2MmU1MWQ0NTcxMzkxMTYyMDg=" title="https://juejin.im/post/5c727262e51d457139116208">dyld背后的故事&amp;源码分析<i class="fa fa-external-link"></i></span> 可以得知，本地的Framework中的类一定会早于后注入的库（动态库例外，非越狱设备是没有插入动态库的权限的）和可执行文件中的类进行初始化。所以我们将 fishhook 的 HOOK 操作代码移到自建的 Framework 中即可：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/169594b4948ff0c2?w=2494&amp;h=1860&amp;f=png&amp;s=694725" alt><br>&emsp;至此，我们已经知道了 fishhook 反调试的基本思路，当然，上面的代码只是思路演示，实际开发中，像<code>method_getImplementation</code>、<code>method_setImplementation</code>等函数都需要用同样的方式一一 HOOK，同时，如果自己的项目中已经用到了这些函数，还需要设计相应的白名单方案，并且在检测到是被三方非法 HOOK 时通常直接调用 <code>exit(0)</code> 这类接口终止掉进程。这些细节以后还会详细讲，这里算是抛砖引玉吧。</p><p>&emsp;那咱们进入第二个正题，源码分析。</p><h2 id="fishhook-源码分析"><a href="#fishhook-源码分析" class="headerlink" title="fishhook 源码分析"></a>fishhook 源码分析</h2><p>（一）： 在写 fishhook 的代码时，第一件事就是声明一个 <code>rebinding</code> 类型的结构体变量，其源码如下：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695c850d3d03ff9?w=878&amp;h=198&amp;f=png&amp;s=43808" alt><br>命名很易读，其中第三个成员 <code>void **replaced</code> 是指向指针的指针，可以理解为一个存着另一个指针地址的指针，在上述示例中， <code>*replaced</code> 取出的就是一个指向共享库中 <code>method_exchangeImplementations</code> 函数实现的指针，再对其取值，<code>**replaced</code> 得到的就是共享库中 <code>method_exchangeImplementations</code> 函数实现的首地址，还不清楚的同学要自己去补补基础了😝。  </p><p>（二）： 按结构体成员的类型写好声明和实现之后，一一赋值给结构体对应的成员，再把这些结构体放到一个数组中，然后调用重绑定符号函数 <code>rebind_symbols</code>(如果绑定成功返回 0，否则返回 -1)，并将结构体数组和数组长度作为参数传入：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695cae0b9629ec3?w=944&amp;h=390&amp;f=png&amp;s=83538" alt><br>接下来咱们一步步的分析在这个函数里具体都做了些啥：</p><ol><li>第一件事，调用了这个函数– <code>prepend_rebindings</code>，其具体实现如下：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695cea53a257331?w=2154&amp;h=754&amp;f=png&amp;s=308406" alt><br>&emsp;咦？传入的第一个参数 <code>&amp;_rebindings_head</code> 是个啥东东？<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695d086c82405eb?w=1508&amp;h=292&amp;f=png&amp;s=95376" alt><br>&emsp;看源码：<code>_rebindings_head</code> 被声明为一个指向 <code>rebindings_entry</code> 类型结构体的静态指针变量，那 <code>&amp;_rebindings_head</code> 就是取出这个指针的地址，再看该函数的参数声明 <code>struct rebindings_entry **</code> ，没错，这又是一个指向指针的指针。<br>&emsp;结构体 <code>rebindings_entry</code> 的三个成员分别是：指向 <code>rebinding</code> 类型结构体的指针（用来指向传入结构体数组的首元素地址）、<code>rebindings_nel</code>：记录此次要重绑定的数量（用于开辟对应大小的空间）、指向下一个 <code>rebindings_entry</code> 类型的结构体（记录下一次需要重绑定的数据），这就是典型的数据结构——<strong>链表</strong>的一种实现。<code>_rebindings_head</code> 就是指向该链表的指针。</li></ol><p>&emsp;为了加深理解，我为你画了一张 <code>prepend_rebindings</code> 函数的作用示意图：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695d2a2cc17541c?w=1884&amp;h=1010&amp;f=png&amp;s=486382" alt><br>&emsp;一句话<strong>总结</strong> <code>prepend_rebindings</code> 函数的目的：<strong>将新加入的 rebindings 数组不断的添加到 _rebindings_head 这个链表的头部成为新的头节点</strong>。  </p><ol start="2"><li>第二件事，对已经载入的镜像文件（也就是库）逐一查找目标符号进行 hook。前面我们已经知道 fishhook 的代码执行时间非常早，所以第一次执行时要 hook 的库可能还没完成装载，因此这里如果是第一次调用会通过一个函数对库的装载完成注册监听和回调的方法：<br><code>`</code></li></ol><p>extern void _dyld_register_func_for_add_image(void (<em>func)(const struct mach_header</em> mh, intptr_t vmaddr_slide))    <strong>OSX_AVAILABLE_STARTING(</strong>MAC_10_1, __IPHONE_2_0);<br><code>`</code><br>&emsp;源码注释如下图：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695d6d6e247bfb0?w=2478&amp;h=1006&amp;f=png&amp;s=508797" alt><br>&emsp;当回调到 <code>_rebind_symbols_for_image</code> 时，会将存着待绑定函数信息的链表作为参数传入，用于符号查找和函数指针的交换，第二个参数 <code>header</code>是 当前 <code>image</code> 的头信息，第三个参数 <code>slide</code>是 ASLR 的偏移：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695d6eb79d40984?w=1668&amp;h=186&amp;f=png&amp;s=80972" alt></p><ol start="3"><li><p>第三件事，根据 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzdiNDM5NzZmYjlhMDRhMDU0MDYzMTIjaGVhZGluZy02" title="https://juejin.im/post/5c7b43976fb9a04a05406312#heading-6">fishhook 是如何根据字符串对应在符号表中的指针，找到其在共享库的函数实现<i class="fa fa-external-link"></i></span> 中的几个步骤，去找到目标符号对应指针所指向的函数实现地址：<br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695d7c4b9fdf0a0?w=2098&amp;h=1194&amp;f=png&amp;s=604072" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/8/1695d7d32860aa77?w=1982&amp;h=1574&amp;f=png&amp;s=813601" alt><br>&emsp;这个过程比较枯燥，无非就是按照规则计算各种表的地址和指针在表中的偏移量。</p></li><li><p>最后一件事，根据算好的符号表地址和偏移量，找到在符号表中用于指向共享库目标函数的指针，然后将该指针的值（即目标函数的地址）赋值给我们的 <code>*replaced</code>，最后修改该指针的值为我们的 <code>replacement</code>（新的函数地址），<code>perform_rebinding_with_section</code> 的源码实现：<br><img src="https://user-gold-cdn.xitu.io/2019/3/13/1697768c5f4ae694?w=1314&amp;h=951&amp;f=png&amp;s=300287" alt></p></li></ol><h2 id="fishhook-源码之旅，告一段落"><a href="#fishhook-源码之旅，告一段落" class="headerlink" title="fishhook 源码之旅，告一段落"></a>fishhook 源码之旅，告一段落</h2><p>&emsp;如果不算注释，fishhook 的源码实现一共 180+ 行，通过对其源码的分析，如果做到读懂它的每一行，我相信不管是对指针的理解和使用，还是对链表的数据结构和实现方式，你都会有更好的理解。当然，你对 MachO 的文件结构和加载机制，也更加了然于胸，同时还 get 了基本的安全防护技巧。</p><p>愿你不虚此行。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 源码分析 </tag>
            
            <tag> fishhook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fishhook的实现原理浅析</title>
      <link href="/2019/03/04/fishhook%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/2019/03/04/fishhook%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="打开姿势很重要"><a href="#打开姿势很重要" class="headerlink" title="打开姿势很重要"></a>打开姿势很重要</h2><p>&emsp;早些时候，iOS中一提到“黑魔法”、HOOK，很多人第一时间想到的就是 AOP RunTime MethodSwizzling 这些不明觉厉的东西，它们的基本用法其实都不难，真正难的是如何在合适的地方用好它们。  </p><p>&emsp;任何事物都有两面性，越强大其可能带来的隐患也越具有毁灭性。苹果提供的运行时机制固然大有用处，但如果在项目中滥用（更不是用来当做面试提升逼格的），很多时候只会适得其反，详细误区请参考<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWExZmNlZGRmMjY1ZGE0MzMxMGQ5OTg1" title="https://juejin.im/entry/5a1fceddf265da43310d9985">iOS界的毒瘤-MethodSwizzling<i class="fa fa-external-link"></i></span>。</p><p>&emsp;关于 MethodSwizzling 的用法在之前的文章中也有过讲解，请参考<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzYxNjU1MmYyNjVkYTJkZDUzZmE0ZTcjaGVhZGluZy0z" title="https://juejin.im/post/5c616552f265da2dd53fa4e7#heading-3">MethodSwizzling的几种姿势<i class="fa fa-external-link"></i></span>。 该方式更多的用于性能监测、 crash 的兼容和上报、反破解防护等一些工具的开发中，而在逆向中，在面对有相应安全防护措施的应用时，其用武之地比较有限。  </p><p>&emsp;无独有偶，“黑魔法”可不只有 RunTime ，今天我们来聊聊在逆向中常用的另一种HOOK方式：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29r" title="https://github.com/facebook/fishhook">fishhook<i class="fa fa-external-link"></i></span>。  </p><h2 id="fishhook-背后的故事"><a href="#fishhook-背后的故事" class="headerlink" title="fishhook 背后的故事"></a>fishhook 背后的故事</h2><h3 id="（一）实现原理"><a href="#（一）实现原理" class="headerlink" title="（一）实现原理"></a>（一）实现原理</h3><p>&emsp;<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29r" title="https://github.com/facebook/fishhook">fishhook<i class="fa fa-external-link"></i></span> 是 FaceBook 开源的可以动态修改 MachO 符号表的工具。fishhook 的强大之处在于它可以 HOOK 系统的静态 C 函数。  </p><p>&emsp;大家都知道 OC 的方法之所以可以 HOOK 是因为它的运行时特性，OC 的方法调用在底层都是 msg_send（id,SEL）的形式，这为我们提供了交换方法实现（IMP）的机会，但 C 函数在编译链接时就确定了函数指针的地址偏移量（Offset），这个偏移量在编译好的可执行文件中是固定的，而可执行文件每次被重新装载到内存中时被系统分配的起始地址（在 lldb 中用命令<code>image List</code>获取）是不断变化的。运行中的静态函数指针地址其实就等于上述 Offset + Mach0 文件在内存中的首地址：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947b64d99d9f8c?w=2190&amp;h=94&amp;f=png&amp;s=49031" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/3/16942fad623530bf?w=1940&amp;h=76&amp;f=png&amp;s=29877" alt></p><p>&emsp;既然 C 函数的指针地址是相对固定且不可修改的，那么 fishhook 又是怎么实现 对 C 函数的 HOOK 呢？<strong>其实内部/自定义的 C 函数 fishhook 也 HOOK 不了，它只能HOOK Mach-O 外部（共享缓存库中）的函数</strong>。fishhook 利用了 MachO 的动态绑定机制（不清楚的同学看这里：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzY3ZTdlZmU1MWQ0NTE2NGM3NTk5M2I=" title="https://juejin.im/post/5c67e7efe51d45164c75993b">MachO 文件结构详解<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzcyNzI2MmU1MWQ0NTcxMzkxMTYyMDg=" title="https://juejin.im/post/5c727262e51d457139116208">dyld背后的故事&amp;源码分析<i class="fa fa-external-link"></i></span>）：苹果的共享缓存库不会被编译进我们的 MachO 文件，而是在动态链接时才去重新绑定。苹果采用了<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9zaXRpb24taW5kZXBlbmRlbnRfY29kZQ==" title="https://en.wikipedia.org/wiki/Position-independent_code">PIC<i class="fa fa-external-link"></i></span>（Position-independent code）技术成功让 C 的底层也能有动态的表现：</p><ul><li>编译时在 Mach-O 文件 _DATA 段的符号表中为每一个被引用的系统 C 函数建立一个指针（8字节的数据，放的全是0），这个指针用于动态绑定时重定位到共享库中的函数实现。</li><li>在运行时当系统 C 函数被第一次调用时会动态绑定一次，然后将 Mach-O 中的 _DATA 段符号表中对应的指针，指向外部函数（其在共享库中的实际内存地址）。  </li></ul><p>fishhook 正是利用了 PIC 技术做了这么两个操作：</p><ul><li>将指向系统方法（外部函数）的指针重新进行绑定指向内部函数/自定义 C 函数。</li><li>将内部函数的指针在动态链接时指向系统方法的地址。</li></ul><p>这样就把系统方法与自己定义的方法进行了交换，达到 HOOK 系统 C 函数（共享库中的）的目的。</p><h3 id="（二）用汇编解析过程"><a href="#（二）用汇编解析过程" class="headerlink" title="（二）用汇编解析过程"></a>（二）用汇编解析过程</h3><p>&emsp;为了更好的理解 fishhook 是如何 HOOK 系统的 C 函数，我们以 HOOK NSLog 为例，从汇编着手来一步步去分析，为大家扒开 fishhook 实现 HOOK 系统 NSLog 的全过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：对于非懒加载符号表，dyld 会在动态链接时就链接动态库</span><br><span class="line">    对于懒加载符号表，dyld 会在运行时函数第一次被调用时动态绑定一次</span><br><span class="line">    NSLog 在懒加载表中</span><br></pre></td></tr></table></figure></p><h4 id="1-验证系统的动态绑定："><a href="#1-验证系统的动态绑定：" class="headerlink" title="1.验证系统的动态绑定："></a>1.验证系统的动态绑定：</h4><p>&emsp;新建一个空工程，写下这两行代码：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947bdfdc4adf78?w=1598&amp;h=358&amp;f=png&amp;s=105901" alt><br>&emsp;编译一下工程，在目录Products下将 .app内的可执行文件拷出用 MachOView 打开：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947c1c922ccad7?w=2160&amp;h=884&amp;f=png&amp;s=639106" alt><br>记下0x3028这个偏移值，这就是用于重定向到共享库中的那个指针相对于 MachO文件的偏移量。  </p><p>在两个 NSLog 处分别加上断点，将工程 Run 起来，把 Debug -&gt; Debug Workflow -&gt; Always Show Disassembly 勾选上，用于查看汇编信息，断点断住后获取 MachO 在内存中的首地址：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947c95a6955ec6?w=2166&amp;h=78&amp;f=png&amp;s=50586" alt><br><strong>0x3028+0x000000010b0f7000</strong> 就是用于重定向到共享库中的那个指针的内存地址。此时我们查看该地址是否已经被重定向：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947d3fb8eb1b03?w=2148&amp;h=1440&amp;f=png&amp;s=811608" alt></p><ol><li>拿到该指针当前保存的值，iOS 的 CPU 是小端序，当前机型为 64 位 CPU，所以倒序读 8 个字节就是指针的值：<strong>0x010b0f89a0</strong></li><li>dis -s 是反汇编命令，我们发现此时该指针指向的函数正在调用系统动态绑定的函数</li><li>进一步查看调用函数详细信息：libdyld.dylib`dyld_stub_binder</li></ol><p>这是在干嘛？没错，这就是第一次调用 NSLog 时系统去重新绑定位懒加载符号表中 NSLog 对应的指针所指向的位置。</p><p>接下来我们过掉第一次断点，让断点断在第二个 NSLog 处，再次查看符号表中该指针（依然是 <strong>0x3028+0x000000010b0f7000</strong> 这个地址）所指向的地址，<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947e1e12c3ce60?w=2180&amp;h=972&amp;f=png&amp;s=567653" alt><br>&emsp;我们发现，它指向的地址由之前的 <strong>0x010b0f89a0</strong><br>变为 <strong>0x010b491276</strong> 了，对应的函数也由之前的 dyld_stub_binder 变为 NSLog ，这意味着该函数的动态绑定已经完成。以上，我们验证了 iOS 的动态绑定全过程。</p><h4 id="2-验证-fishhook-的重绑定："><a href="#2-验证-fishhook-的重绑定：" class="headerlink" title="2.验证 fishhook 的重绑定："></a>2.验证 fishhook 的重绑定：</h4><p>&emsp;我们将 fishhook文件拖入工程，并添加一个简单的绑定：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947f1ff35ebade?w=2758&amp;h=1580&amp;f=png&amp;s=575055" alt><br><strong>注意：修改文件后重新编译的 MachO 文件，符号表里的指针偏移值可能会改变，重新运行的程序内存首地址也会发生变化，需要你重新拿到它们计算得出指针新的内存地址。</strong> </p><p>我们运行起来之后点击屏幕进入上图所示断点，查看符号表中原本指向系统 NSLog 的指针指向：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16947f8a82a1d9a9?w=2304&amp;h=494&amp;f=png&amp;s=226668" alt><br>此时该指针的指向被修改为我们自定义的函数 myNslog 了，而将系统重定位的外部函数地址保存到了另一个自定义函数指针 sys_nslog 中：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/169482b537e87b2d?w=2806&amp;h=962&amp;f=png&amp;s=555777" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/4/169482c7f96c4e78?w=2792&amp;h=496&amp;f=png&amp;s=368451" alt><br>以上，我们通过断点分析汇编信息，验证了 fishhook 实现 HOOK 系统外部函数的思路。接下来我们结合 fishhook 的官方说明看它是如何根据字符串（方法名）找到对应指针在符号表中的偏移值的。</p><h3 id="（三）fishhook-是如何根据字符串对应在符号表中的指针，找到其在共享库的函数实现的？"><a href="#（三）fishhook-是如何根据字符串对应在符号表中的指针，找到其在共享库的函数实现的？" class="headerlink" title="（三）fishhook 是如何根据字符串对应在符号表中的指针，找到其在共享库的函数实现的？"></a>（三）fishhook 是如何根据字符串对应在符号表中的指针，找到其在共享库的函数实现的？</h3><p>fishhook 官方给了这张图：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/1694835612995c46?w=1528&amp;h=1808&amp;f=png&amp;s=375686" alt><br>这张图主要在描述如何由一个字符串（比如 “NSLog”），跟着它在 MachO 文件的懒加载表中对应的指针，一步步的找到该指针指向的函数实现地址，大致步骤如下：</p><ol><li>在 Lazy Symbol Pointers 中该字符串的顺序就是其在 Dynamic Symbols Table -&gt; Indirect Symbols 表中的位置（这里是第一个）<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/169485350abfa446?w=2132&amp;h=832&amp;f=png&amp;s=623817" alt><br>在实际计算地址中用到了 Load Commands 中对应头信息的 Reserved1 的 value （section基地址+  偏移量 value = 其在 Indirect Symbols 中对应的 offset）:下篇<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzgxMDI5NGYyNjVkYTJkYjkxMjk3ZjE=" title="https://juejin.im/post/5c810294f265da2db91297f1">源码分析<i class="fa fa-external-link"></i></span>有详细说明。<br><img src="https://user-gold-cdn.xitu.io/2019/3/13/169773b4e83c6422?w=1072&amp;h=289&amp;f=png&amp;s=93955" alt></li><li>Dynamic Symbols Table -&gt; Indirect Symbols 表中的第一个对应的 Data 值（0x7A=122）就是其在Symbols Table -&gt; Symbols 中的索引。<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16948517a9d15528?w=2184&amp;h=1232&amp;f=png&amp;s=778503" alt></li><li>在 Symbols Table -&gt; Symbols 中索引为 122 的位置对应的 Data = 0x9B：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/169484c4a38ad17e?w=2156&amp;h=1316&amp;f=png&amp;s=751016" alt></li><li>上表中的 Data（0x9B） + String Table的起始地址（0x4F04）就是目标函数实现的地址：<br><img src="https://user-gold-cdn.xitu.io/2019/3/4/16948458a00d9911?w=2148&amp;h=1324&amp;f=png&amp;s=1032207" alt></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;今天我们结合 iOS 的共享缓存库中采用的 PIC 技术，介绍了 fishhook 对系统外部函数实现 HOOK 基本原理和具体过程，并通过反汇编命令一一验证了 iOS 的动态绑定过程和 fishhook 的重新绑定机制，最后把 fishhook 在符号表中根据符号指针寻找函数实现的步骤做了演示。 愿你有所收获！ 水平有限，请多指教~</p><p>&emsp;鉴于篇幅过长会影响大家的阅读体验，fishhook 的源码分析与应用场景以及安全防护的分享，<a href="https://enjoycoding007.github.io/2019/03/08/fishhook%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&amp;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">我们这里继续</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> fishhook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dyld背后的故事&amp;源码分析</title>
      <link href="/2019/02/25/dyld%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B&amp;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/02/25/dyld%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B&amp;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是dyld？"><a href="#什么是dyld？" class="headerlink" title="什么是dyld？"></a>什么是dyld？</h2><p>&emsp;dyld（the dynamic link editor）是苹果的动态链接器，是苹果操作系统的一个重要组成部分，当系统内核做好启动程序的准备工作之后，余下的工作会交给dyld来负责处理。那它存在的意义是什么？它又具体都负责做些什么呢？这一篇我们一起来一探究竟。前方长篇预警~</p><hr><h2 id="dyld存在的意义"><a href="#dyld存在的意义" class="headerlink" title="dyld存在的意义"></a>dyld存在的意义</h2><p>&emsp;存在即合理，但我们要弄清楚其合理性所在。先从可执行文件是如何由源码生成的说起。</p><h3 id="1-可执行文件的生成–静态链接。"><a href="#1-可执行文件的生成–静态链接。" class="headerlink" title="1.可执行文件的生成–静态链接。"></a>1.可执行文件的生成–静态链接。</h3><p>先看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello World\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;假设这段代码源文件为hello.c，我们输入最简单的命令：<code>$gcc hello.c</code> <code>$./a.out</code>，那么终端会输出：Hello World，在这个过程中，事实上经过了四个步骤：预处理、编译、汇编和链接。我们来具体看每一步都做了些什么。  </p><p>&emsp;<strong>预编译</strong>的主要处理规则如下：</p><ol><li>删除所有#define，并将所有宏定义展开 </li><li>将被包含的文件插入到预编译指令(#include)所在位置（这个过程是递归的）</li><li>删除所有注释：// 、/<em> </em>/等</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及编译时能够显示警告和错误的所在行号</li><li>保留所有的#pragma编译器指令，因为编译器须要使用它们</li></ol><p>结合上述规则，当我们无法判断宏定义是否正确或者头文件是否包含时可以查看预编译后的文件来确定问题，预编译的过程相当于如下命令：<br><code>$gcc -E hello.c -o hello.i</code> 或<br><code>$cpp hello.c &gt; hello.i</code>  </p><p>&emsp;<strong>编译</strong>的过程就是把预处理完的文件进行一些列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们整个程序构建的核心部分，也是最复杂的部分之一，编译的具体步骤涉及到编译原理等内容，这里就不展开了。我们使用命令：<br><code>$gcc -S hello.c -o hello.s</code><br>可以得到汇编输出文件hello.s。  </p><p>&emsp;对于 C 语言的代码来说，这个预编译和编译的程序是 ccl，但是对于 C++ 来说，对应的程序是 ccplus；Objective-C 的是 ccobjc；Java 是 jcl。所以实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序 ccl、汇编器 as、链接器 ld。</p><p>&emsp;<strong>汇编器</strong>是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，我们使用命令：<br><code>$as hello.s -o hello.o</code> 或<br><code>$gcc -c hello.s -o hello.o</code><br>来完成汇编，输出<strong>目标文件</strong>（Object File）：hello.o。  </p><p>&emsp;<strong>链接</strong>是让很多人费解的一个过程，为什么汇编器不直接输出可执行文件而是一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？  </p><p>&emsp;这就要扯一下计算机程序开发的历史了，最早的时候程序员是在纸带上用机器语言通过打孔来实现程序的，连汇编语言都没有，每当程序修改的时候，修改的指令后面的位置要相应的发生移动，程序员要人工计算每个子程序或跳转的目标地址，这个过程叫<strong>重定位</strong>。很显然这样修改程序的代价随着程序的增大会变得高不可攀，并且很容易出错，于是有先驱发明了汇编语言，汇编语言使用接近人类的各种符号和标记来帮助记忆，更重要的是，这种符号使得人们从具体的指令地址中逐步解放出来，当人们使用这种符号命名子程序或者跳转目标以后，不管目标指令之前修改了多少指令导致目标指令的地址发生了变化，汇编器在每次汇编程序的时候都会重新计算目标指令的地址，然后把所有引用到该指令的指令修正到正确的地址，这个过程不需要人工参与。  </p><p>&emsp;有了汇编语言，生产力极大地提高了，随之而来的是软件的规模与日俱增，代码量快速膨胀，导致人们开始考虑将不同功能的代码以一定的方式组织起来，使得更加容易阅读和理解，更便于日后修改和复用。自然而然的，我们开始习惯用若干个变量和函数组成一个模块（比如类），然后用目录结构来组织这些源代码文件，在一个程序被多个模块分割以后，这些模块最终如何组合成一个单一的程序是须要解决的问题。这个问题归根结底是模块之间如何通信的问题，也就是访问函数需要知道函数的地址，访问变量需要知道变量的地址，这两个问题都是通过模块间符号的引用的方式来解决。这个模块间符号引用拼接的过程就是<strong>链接</strong>。  </p><p>&emsp;<strong>链接</strong>的主要内容就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接。本质上跟前面描述的“程序员人工调整地址”没什么区别，只不过现代的高级语言的诸多特性和功能，使得编译器、链接器更为复杂，功能更强大。<strong>链接</strong>过程包括了<strong>地址和空间分配</strong>、<strong>符号决议</strong>（也叫“符号/地址绑定”，“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即适用范围的区别）和<strong>重定位</strong>，链接器将经过汇编器编译成的所有目标文件和<strong>库</strong>进行<strong>链接</strong>形成最终的可执行文件，而最常见的库就是<strong>运行时库（RunTime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库</strong>其实就是一组最常用的代码编译成目标文件后的打包存放。  </p><p>&emsp;知道了可执行文件是如何生成的，我们再来看看它又是如何被装载进系统中运行起来的。</p><h3 id="2-可执行文件的装载与动态链接。"><a href="#2-可执行文件的装载与动态链接。" class="headerlink" title="2.可执行文件的装载与动态链接。"></a>2.可执行文件的装载与动态链接。</h3><h4 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h4><p>&emsp;装载与动态链接其实内容特别多，很多细节需要对计算机底层有非常扎实的理解，鉴于目前我的能力尚浅，这里只做粗略的介绍，推荐有兴趣的同学购买《程序员的自我修养–链接、装载与库》这本书了解更多细节。  </p><p>&emsp;可执行文件(程序)是一个静态的概念，在运行之前它只是硬盘上的一个文件；而进程是一个动态的概念，它是程序运行时的一个过程，我们知道每个程序被运行起来后，它会拥有自己独立的<strong>虚拟地址空间</strong>，这个地址空间大小的上限是由计算机的硬件（CPU的位数）决定的，比如32位的处理器理论最大虚拟空间地址为0~2^32-1。即0x00000000~0xFFFFFFFF，当然，我们的程序运行在系统上时是不可能任意使用全部的虚拟空间的，操作系统为了达到监控程序运行等一系列目的，进程的虚拟空间都在操作系统的掌握之中，且在操作系统中会同时运行着多个进程，它们彼此之间的虚拟地址空间是隔离的，如果进程访问了操作系统分配给该进程以外的地址空间，会被系统当做非法操作而强制结束进程。  </p><p>&emsp;将硬盘上的可执行文件映射到虚拟内存中的过程就是<strong>装载</strong>，但内存是昂贵且稀有的，所以将程序执行时所需的指令和数据全部装载到内存中显然是行不通的，于是人们研究发现了程序运行时是有<strong>局部性原</strong>理的，可以只将最常用的部分驻留在内存中，而不太常用的数据存放在磁盘里，这也是<strong>动态装载</strong>的基本原理。<strong>覆盖装入</strong>和<strong>页映射</strong>就是利用了局部性原理的两种经典动态装载方法，前者在发明虚拟内存之前使用比较广泛 ，现在基本已经淘汰，主要使用<strong>页映射</strong>。装载的过程也可以理解为进程建立的过程，操作系统只需要做以下三件事情：</p><ol><li>创建一个独立的虚拟地址空间</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li></ol><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>&emsp;前面我们在生成可执行文件时说的链接是静态链接。最后一步是将经过汇编后的所有目标文件与库进行链接形成可执行文件，这里的提到的库，包括了很多<strong>运行时库</strong>。运行时库通常是支持程序运行的基本函数的集合，也就意味着每个进程都会用到它，如果每一个可执行文件都将其打包进自己的可执行文件，都用静态链接的方式，虽然原理上更容易理解，但是这种方式对计算机的内存和磁盘的空间浪费非常严重！在现在的Linux系统中，一个普通的程序会使用到的C语言静态库至少在1M以上，如果系统中有2000个这样的程序在运行，就要浪费将近2G的空间。为了解决这个问题，把运行时库的链接过程推迟到了运行时在进行，这就是<strong>动态链</strong>接（<strong>Dynamic Linking</strong>）的基本思想。动态链接的好处有以下几点：</p><ol><li>解决了共享的目标文件存在多个副本浪费磁盘和内存空间的问题</li><li>减少物理页面的换入换出，还增加了CPU的缓存命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上</li><li>系统升级只需要替换掉对应的共享模块，当程序下次启动时新版本的共享模块会被自动装载并链接起来，程序就无感的对接到了新版本。</li><li>更方便程序<strong>插件</strong>（Plug-in）的制作，为程序带来更好的可扩展性和兼容性。</li></ol><p>&emsp;至此，终于说回了我们今天的主角：<strong>dyld</strong>,现在咱们知道了它存在的意义——动态加载的支持。</p><hr><h2 id="动态链接的步骤"><a href="#动态链接的步骤" class="headerlink" title="动态链接的步骤"></a>动态链接的步骤</h2><p>&emsp;现在，我们理解了为什么需要动态链接，dyld作为苹果的动态链接器，但本质上dyld也是一个共享对象：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/16923803aaf75a12?w=1055&amp;h=116&amp;f=png&amp;s=33618" alt>上图是dyld在系统中的路径，在iPhone中只有获取root权限（也就是越狱）的用户才能访问，后面在逆向实战中会给大家演示。<br>&emsp;既然dyld也是一个共享对象，而普通共享对象的重定位工作又是由dyld来完成的，虽然也可以依赖于其他共享对象，但被依赖的共享对象还是要由dyld来负责链接和装载。那么dyld的重定向由谁来完成呢？dyld是否可以依赖其他的共享对象呢？这是一个“鸡生蛋，蛋生鸡”的问题，为了解决这个问题，<strong>动态链接器</strong>需要有些特殊性：</p><ul><li>动态链接器本身不依赖其他任何共享对象</li><li>动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成</li></ul><p>上述第一个条件在编写动态链接器时可以人为的控制，第二个条件要求动态链接器在启动时必须有一段代码可以在获得自身的重定位表和符号表的同时又不能用到全局和静态变量，甚至不能调用函数，这样的启动代码被称为<strong>自举</strong>（<strong>Bootstrap</strong>）。当操作系统将进程控制权交给动态链接器时，自举代码开始执行，它会找到动态链接器本身的重定位入口（具体过程和原理暂未深究），进而完成其自身的重定位，在此之后动态链接器中的代码才可以开始使用自己的全局、静态变量和各种函数了。  </p><p>&emsp;完成基本的自举以后，动态链接器将可执行文件和链接器本身的符号表合并为一个，称为<strong>全局符号表</strong>。然后链接器开始寻找可执行文件所依赖的共享对象，如果我们把依赖关系看作一个图的话，那么这个装载过程就是一个图的便利过程，链接器可能会使用深度优先或者广度优先也可能其他的算法来遍历整个图，比较常见的算法都是广度优先的。  </p><p>&emsp;每当一个新的共享对象被装载进来，它的符号表会被合并到全局符号表中，装载完毕后，链接器开始重新遍历可执行文件和共享对象的重定位表，将每个需要重新定位的位置进行修正，这个过程与静态链接的重定位原理基本相同。重定位完成之后，动态链接器会开始共享对象的初始化过程，但不会开始可执行文件的初始化工作，这将由程序初始化部分的代码负责执行。当完成了重定位和初始化之后，所有的准备工作就宣告完成了，这时动态链接器就如释重负，将进程的控制权交给程序的入口并且开始执行。 </p><hr><h2 id="dyld源码分析"><a href="#dyld源码分析" class="headerlink" title="dyld源码分析"></a>dyld源码分析</h2><p>&emsp;我们来通过分析dyld的源码验证上述过程：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/16923b9d32a0e4e7?w=1070&amp;h=418&amp;f=png&amp;s=228919" alt><br>新建一个Objective-C的iOS项目作为示例，在任意参与编译的类中重写 +load 方法并添加断点，运行起来进入断点即可看到上图所示的dyld调用堆栈信息。  </p><p>&emsp;从图中frame9的汇编信息中，你一定发现了在dyld的入口函数<code>__dyld_start</code>里出现了<code>dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*)</code>的函数调用，那这段代码是干嘛的呢？上源码：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/16923f6d556eb8ef?w=775&amp;h=908&amp;f=png&amp;s=182757" alt>这个函数做了这么几件事：dyld的<strong>自举</strong>（slideOfMainExecutable、rebaseDyld 完成自身的<strong>重定位</strong>）、开放函数使用：mach_init、设置堆栈保护：__guard_setup、开始装载共享对象：dyld::_main。   </p><p>在dyld::_main中主要做了以下几件事</p><ol><li>配置环境：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/1692435464464110?w=775&amp;h=754&amp;f=png&amp;s=166363" alt></li><li>加载动态库(共享缓存)：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/1692445911c89b2d?w=832&amp;h=241&amp;f=png&amp;s=65009" alt></li><li>实例化主程序：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/169246357df619b5?w=783&amp;h=320&amp;f=png&amp;s=75369" alt></li><li>插入动态库：（越狱中编写插件就是修改这个配置让自己写的库被加载，这个配置也只有root用户才有权限修改，本来是苹果给自己预留插入动态库用的）<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/1692466fbead2ece?w=821&amp;h=121&amp;f=png&amp;s=30037" alt></li><li>重定位完所有需要重定位的库，然后初始化主程序：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/1692481fcc629ace?w=825&amp;h=284&amp;f=png&amp;s=77826" alt><ol><li>经过一系列初始化函数的调用，到notifySingle函数<ul><li>通过断点调试发现此函数的回调是load_images这个函数</li><li>load_images里执行call_load_methods函数<ul><li>循环调用各个类的 load 方法</li></ul></li></ul></li><li>然后调用了 doModInitFunctions 函数<ul><li>内部会调用全局C++对象的构造函数（带<strong>attribute</strong>((constructor))的c函数）</li></ul></li><li>返回主程序的入口函数，进入主程序的main函数：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/169248828b79d71d?w=824&amp;h=505&amp;f=png&amp;s=134011" alt>历经千辛万苦，我们抵达了最熟悉的main函数：<br><img src="https://user-gold-cdn.xitu.io/2019/2/25/169248963302cbc4?w=626&amp;h=125&amp;f=png&amp;s=23679" alt></li></ol></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;这一篇我们从dyld出发，将程序从编译到装载的整个过程串了一遍，并结合分析了dyld的源码，这些资源都是开源的，有兴趣一定要自己去自己啃一下，通过看苹果对数据结构的使用和设计，还是有很多启发的。在后续的逆向学习中，这一篇的研究或许能让我不仅知其然，而且知其所以然。</p><p>路过的大神还望多多指教~</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MachO 文件结构详解</title>
      <link href="/2019/02/21/MachO%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/21/MachO%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概念——什么是MachO？"><a href="#概念——什么是MachO？" class="headerlink" title="概念——什么是MachO？"></a>概念——什么是MachO？</h2><p>&emsp; 苹果开发者对它一定不陌生，特别是喜欢逆向的同学，对它的研究更是必不可少。在可安装的每一个.app包中，都有一个与app同名的可执行文件，它可能长这样：（如果你碰到显示为白色的MachO文件，说明当前用户对其没有<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ2ZGNhZDUxODgyNTI2MGQ3ZWU2MDU=" title="https://juejin.im/post/5c46dcad518825260d7ee605">可执行权限<i class="fa fa-external-link"></i></span>）<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690ec28517fafa3?w=1074&amp;h=254&amp;f=png&amp;s=346927" alt><br>&emsp; MachO其实是Mach Object的缩写，是在Mac以及iOS上可执行的一种文件格式，包括但不限于：可执行文件(.out .o)、动态库、静态库、dyld、目标文件，官方文档中列举如下：<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690f24c1823de3c?w=681&amp;h=348&amp;f=png&amp;s=106692" alt>它类似于Windows上的PE、Linux上的ELF格式，我们用file命令看上图中 AlipayWallet 的文件类型信息：<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690eb457bf08075?w=762&amp;h=70&amp;f=png&amp;s=17346" alt>可以看到，该示例的MachO文件属于通用二进制文件（苹果提出的一种能同时适用多种架构二进制文件的程序代码），并支持在两种架构上运行：arm_v7和arm64，包含了多种架构的MachO文件可以通过lipo thin命令进行拆分：<code>lipo AlipayWallet -thin armv7 -output alipayArmv7</code>，同样也能用lipo create进行合并：<code>lipo alipayArm64 alipayArmv7 -create -output AlipayWalletNew</code>，大家可以自己实践一下。</p><h2 id="构造——MachO的内部结构是怎样的？"><a href="#构造——MachO的内部结构是怎样的？" class="headerlink" title="构造——MachO的内部结构是怎样的？"></a>构造——MachO的内部结构是怎样的？</h2><h3 id="一：简单的讲，它包括以下四个组成部分："><a href="#一：简单的讲，它包括以下四个组成部分：" class="headerlink" title="一：简单的讲，它包括以下四个组成部分："></a>一：简单的讲，它包括以下四个组成部分：</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690ee9ff0ce8d71?w=320&amp;h=362&amp;f=png&amp;s=67394" alt></p><ul><li>Header （头部）<ul><li>用于快速确认该文件的CPU类型、文件类型等信息</li></ul></li><li>LoadCommands （加载命令）<ul><li>用于告诉loader如何设置并加载二进制数据</li></ul></li><li>Data （数据段 segment）<ul><li>存放数据：代码、字符常量、类、方法等</li><li>可以拥有多个segment，每个segment可以有零到多个section。每个段都有一段虚拟地址映射到进程的地址空间</li></ul></li><li>Loader Info （链接信息）<ul><li>一个完整的用户级MachO文件的末端是一系列链接信息。其中包含了动态加载器用来链接可执行文件或者依赖所需使用的符号表、字符串表等  </li></ul></li></ul><p>&emsp; 来用MachOView验证一下该示例的MachO文件结构：<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690ef52aaad8003?w=882&amp;h=842&amp;f=png&amp;s=167368" alt></p><h3 id="二：逐一探索："><a href="#二：逐一探索：" class="headerlink" title="二：逐一探索："></a>二：逐一探索：</h3><h4 id="1-Header"><a href="#1-Header" class="headerlink" title="1.Header"></a>1.Header</h4><p>&emsp; 除了用MachOView能查看MachO文件信息，还可以通过otool命令查看，我们先来分析Header中的内容：<code>otool -h AlipayWallet</code>：<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690efaec026514b?w=662&amp;h=120&amp;f=png&amp;s=18817" alt></p><ul><li>magic：MachO文件的魔数，用来确定其属于64位（0xfeedfacf）还是32位（0xfeedface）例子中有两个Header，分别对应的是armv7和arm64的Header，前者32位，后者64位。</li><li>cputype和cupsubtype代表的是cpu的类型和其子类型，例子中分别是12(c)与9、16777228(100000c)与0定义如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CPU_TYPE_ARM((cpu_type_t) 12)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7((cpu_subtype_t) 9)</span><br><span class="line">#define CPU_TYPE_ARM64((cpu_type_t) 16777228)</span><br><span class="line">#define CPU_SUBTYPE_AR64M_ALL((cpu_subtype_t) 0)</span><br></pre></td></tr></table></figure><ul><li>接着是filetype，2，代表可执行的文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#defineMH_EXECUTE0x2/* demand paged executable file */</span><br><span class="line">```  </span><br><span class="line">* ncmds 指的是加载命令(load commands)的数量，例子中一共75个，编号0-74</span><br><span class="line">* sizeofcmds 表示75个load commands的总字节大小， load commands区域是紧接着header区域的</span><br><span class="line">* 最后个flags 标识二进制文件支持的功能，主要与系统的加载、链接有关。</span><br><span class="line"></span><br><span class="line">这里为你准备了 mach_header 的苹果官方文档说明：（更多详细定义请参考[loader.h](https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h)）</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/2/21/1690f152b4cd7c0e?w=896&amp;h=736&amp;f=png&amp;s=192704)</span><br><span class="line">#### 2.LoadCommands</span><br><span class="line">我们继续用命令查看：`otool -l  alipayArm64`，该示例共有75个加载指令，我们只截取一个作为代表，分别为出现在segment和section中的每一个参数进行注释：</span><br></pre></td></tr></table></figure></li></ul><p>Load command 1<br>      cmd LC_SEGMENT_64         // cmd 是load command的类型，LC_SEGMENT_64的含义是将这个64位的段映射到进程地址空间，即加载命令<br>  cmdsize 712                   // 代表load command的大小<br>  segname <strong>TEXT                // 16字节的段名字 </strong>TEXT<br>   vmaddr 0x0000000100000000    // 段的虚拟内存起始地址<br>   vmsize 0x00000000036a4000    // 段的虚拟内存大小<br>  fileoff 0                     // 段在文件中的偏移量<br> filesize 57294848              // 段在文件中的大小<br>  maxprot 0x00000005            // 段页面所需要的最高内存保护（4=r,2=w,1=x）<br> initprot 0x00000005            // 段页面初始的内存保护<br>   nsects 8                     // 段中包含section的数量<br>    flags 0x0                   // 其他杂项标志位<br>Section<br>  sectname <strong>text               // 第一个是</strong>text ,就是主程序代码<br>   segname <strong>TEXT               // 该section所属的 segment名，第一个是</strong>TEXT<br>      addr 0x0000000100006110   // 该section在内存的启始位置，0x100006110<br>      size 0x000000000358a268   // size 该section的大小，0x358a268<br>    offset 24848                // 24848 0x6110<br>     align 2^4 (16)             // 字节大小对齐，16<br>    reloff 0                    // 重定位入口的文件偏移 0<br>    nreloc 0                    // 需要重定位的入口数量 0<br>     flags 0x80000400           // 包含section的type和attributes<br> reserved1 0                    // …保留用<br> reserved2 0                    // …保留用<br><code>`</code><br>注释完毕，我又为你准备了 segment和section 的苹果官方文档说明：（更多详细定义请参考<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS9zb3VyY2UveG51L3hudS0xNDU2LjEuMjYvRVhURVJOQUxfSEVBREVSUy9tYWNoLW8vbG9hZGVyLmg=" title="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h">loader.h<i class="fa fa-external-link"></i></span>）<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690f6dfda1854aa?w=765&amp;h=912&amp;f=png&amp;s=266593" alt><br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690f6ec5d6bea68?w=762&amp;h=786&amp;f=png&amp;s=239036" alt><br>&emsp; 我总结了最常见的加载命令如下：<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690fa76882c8af7?w=268&amp;h=322&amp;f=png&amp;s=26066" alt><br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690fbc34565600d?w=221&amp;h=53&amp;f=png&amp;s=4528" alt></p><ul><li><strong>LC_SEGMENT_64</strong>： 将该段(64位)映射到进程地址空间中</li><li><strong>LC_DYLD_INFO_ONLY</strong>：加载动态链接库信息（重定向地址、弱引用绑定、懒加载绑定、开放函数等的偏移值等信息）</li><li><strong>LC_SYMTAB</strong>：载入符号表地址</li><li><strong>LC_DYSYMTAB</strong>：载入动态符号表地址</li><li><strong>LC_LOAD_DYLINKER</strong>：加载动态加载库，可以看出示例使用的是/usr/lib/dyld<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690fb2174b662e0?w=1093&amp;h=113&amp;f=png&amp;s=32934" alt></li><li><strong>LC_UUID</strong>：确定文件的唯一标识，crash解析中也会有这个，去检测dysm文件和crash文件是否匹配</li><li><strong>LC_VERSION_MIN_MACOSX</strong>/LC_VERSION_MIN_IPHONEOS：确定二进制文件要求的最低操作系统版本</li><li><strong>LC_SOURCE_VERSION</strong>：构建该二进制文件使用的源代码版本</li><li><strong>LC_MAIN</strong>：设置程序主线程的入口地址和栈大小</li><li><strong>LC_ENCRYPTION_INFO_64</strong>：获取加密信息</li><li><strong>LC_LOAD_DYLIB</strong>：加载额外的动态库</li><li><strong>LC_FUNCTION_STARTS</strong>：定义一个函数起始地址表,使调试器和其他程序易于看到一个地址是否在函数内</li><li><strong>LC_DATA_IN_CODE</strong>：定义在代码段内的非指令的表</li><li><strong>LC_CODE_SIGNATURE</strong>：获取应用签名信息<h4 id="3-Data、链接信息"><a href="#3-Data、链接信息" class="headerlink" title="3.Data、链接信息"></a>3.Data、链接信息</h4>&emsp; 如果说前面两部分的主要作用，是让kern内核知道如何读取MachO文件，并指定MachO文件的动态链接器(dyly)用来完成后续的动态库加载，然后设置好程序入口等一些列程序启动前的信息，那么Data和链接信息部分，就相当于当程序运行起来后，为每一个映射到虚拟内存中的指令操作提供真实的物理地址支持。详细的过程会面会单独写一篇文章展开来讲。</li></ul><h2 id="收获——熟悉MachO可以做什么"><a href="#收获——熟悉MachO可以做什么" class="headerlink" title="收获——熟悉MachO可以做什么"></a>收获——熟悉MachO可以做什么</h2><p>&emsp; 理解原理很重要，了解MachO格式的结构和加载运行，不仅可以帮助我们理解MacOS和iOS的app可执行文件启动过程，还能做且不限于：</p><ul><li>bitcode分析</li><li>crash符号化</li><li>符号模块查找</li><li>非OC函数switch</li><li>包支持架构分析</li><li>常量字符串分析</li><li>进程启动速度优化</li><li>学习经典的数据结构</li></ul><p>希望你有所收获！下篇我们主要<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzcyNzI2MmU1MWQ0NTcxMzkxMTYyMDg=" title="https://juejin.im/post/5c727262e51d457139116208">围绕dyld讲动态加载过程<i class="fa fa-external-link"></i></span>，see you~</p><hr><p>参考文章：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81NGQ4NDJkYjNmNjk=" title="https://www.jianshu.com/p/54d842db3f69">趣探 Mach-O：文件格式分析<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqdHVmYW5nL2FydGljbGUvZGV0YWlscy81MDYyODMxMA==" title="https://blog.csdn.net/bjtufang/article/details/50628310">Mach-O文件格式和程序从加载到执行过程<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> MachO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非越狱下iOS代码注入&amp;微信登录HOOK</title>
      <link href="/2019/02/10/%E9%9D%9E%E8%B6%8A%E7%8B%B1%E4%B8%8BiOS%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5&amp;%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95HOOK/"/>
      <url>/2019/02/10/%E9%9D%9E%E8%B6%8A%E7%8B%B1%E4%B8%8BiOS%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5&amp;%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95HOOK/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在之前这篇<a href="https://enjoycoding007.github.io/2019/01/23/%E6%92%B8%E4%B8%80%E4%B8%AAiOS%E9%87%8D%E7%AD%BE%E5%90%8D%E8%84%9A%E6%9C%AC/">iOS应用脚本重签名</a>中，我们对脱壳的微信安装包进行重签名，并成功在真机上运行起来，完成了iOS逆向的准备工作。这一篇我们将通过演示如何HOOK微信登录事件并获取到用户密码，把iOS代码注入的几种方式串起来做个简单地概述。不管做逆向还是正向开发，这些都能为你提供一些在应用安全攻防方面的思路。<br>&emsp;当拿到别人的脱壳包，想要HOOK别人的方法做些小插件，首先需要程序执行你写的代码，你才有机会利用runtime的运行时机制去做自己的事情，关于方法混淆的注意事项请参考<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWExZmNlZGRmMjY1ZGE0MzMxMGQ5OTg1" title="https://juejin.im/entry/5a1fceddf265da43310d9985">这一篇<i class="fa fa-external-link"></i></span>。让程序执行我们写的代码就需要修改MachO文件，关于MachO我在<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzY3ZTdlZmU1MWQ0NTE2NGM3NTk5M2I=" title="https://juejin.im/post/5c67e7efe51d45164c75993b">这一篇<i class="fa fa-external-link"></i></span>里详细讲解了，这篇主要讲代码注入的事儿：  </p><ol><li><h3 id="Framework注入"><a href="#Framework注入" class="headerlink" title="Framework注入"></a>Framework注入</h3> 添加自己的Framework：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e075c1e8eafc8?w=2320&amp;h=1048&amp;f=png&amp;s=1057376" alt><br> 写好测试代码，在<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQ2MDkwOGYyNjVkYTYxNjcyMDliODc=" title="https://juejin.im/post/5c460908f265da6167209b87">上一篇<i class="fa fa-external-link"></i></span>重签名脚本的基础上加一行修改MachO加载路径的代码：<code>yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;Frameworks/SharonFramework.framework/SharonFramework&quot;</code>，Framework文件名为你自己刚刚添加的。直接Run！<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0762658096c8?w=2294&amp;h=842&amp;f=png&amp;s=274662" alt><br>大功告成。</li><li><h3 id="Dylib注入"><a href="#Dylib注入" class="headerlink" title="Dylib注入"></a>Dylib注入</h3> 添加自己的Dylib：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e07d75b2604bf?w=2360&amp;h=1146&amp;f=png&amp;s=1189863" alt>&emsp;要注意的是这样添加的MacOS的Dylib需要将BuildSetting–&gt;Base SDK改为iOS，BuildSetting–&gt;CODE SIGN IDENTITY改为iPhone Developer即可在iPhone上运行。<br>另外，与Framework不同的是它需要手动添加关联库：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0849536db686?w=1964&amp;h=988&amp;f=png&amp;s=335435" alt><br>同样在重签名脚本中加一行修改MachO可执行文件路径的代码：<code>yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;Frameworks/libSharonLibrary.dylib&quot;</code>，dylib文件名为你自己刚刚添加的。直接Run！<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e08c6363b234e?w=2606&amp;h=940&amp;f=png&amp;s=716314" alt></li></ol><p>&emsp;至此我们已经完成了代码注入的第一步，让别人的应用在运行时执行我们写的代码，这个过程中你可能会碰到签名不成功等各种各样的奇葩问题，不要慌，静下心分析，实在不行你可以留言^_^ ~，接下来我们要尝试HOOK微信的登录按钮事件。</p><p>&emsp;同步几个共识：</p><ul><li>+load 方法的调用发生在类或分类被 runtime 加载（编译后的可执行文件被装载到内存中）时，只调用1次。</li><li>子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。</li><li>如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。</li><li>不同的类之间的 +load 方法的调用顺序是不确定的。</li><li>基于+load方法的上述特点，它是实现方法混淆的最佳入口。</li></ul><h3 id="通过viewDebug-头文件分析目标Method"><a href="#通过viewDebug-头文件分析目标Method" class="headerlink" title="通过viewDebug+头文件分析目标Method"></a>通过viewDebug+头文件分析目标Method</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0996ece0134e?w=3252&amp;h=1652&amp;f=png&amp;s=2018571" alt><br>如上图所示，我们很快定位到登录按钮的target为WCAccountLoginControlLogic，action为onFirstViewLogin，我们在通过头文件分析一下，class-dump怎么用相信你Google一下就搞得定，这里就不赘述啦，拿到微信的所有头文件丢到sublime里全局搜索：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e09d0d2330657?w=2630&amp;h=832&amp;f=png&amp;s=186284" alt>果然，找到了目标文件，点击进入头文件查看Method列表：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e09ef308cca22?w=2686&amp;h=1300&amp;f=png&amp;s=482886" alt>验证了我们的分析是正确的。<br>用同样的方式我们定位账号密码输入页登录按钮的target为WCAccountMainLoginViewController，action为onNext：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0ac7c81e0b1a?w=3316&amp;h=1492&amp;f=png&amp;s=805760" alt><br>我们将通过HOOK登录按钮点击事件获取密码输入框里的内容。</p><h3 id="MethodSwizzling的几种姿势"><a href="#MethodSwizzling的几种姿势" class="headerlink" title="MethodSwizzling的几种姿势"></a>MethodSwizzling的几种姿势</h3><ol><li><h3 id="class-replaceMethod"><a href="#class-replaceMethod" class="headerlink" title="class_replaceMethod"></a>class_replaceMethod</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0ba6c8276ea2?w=2626&amp;h=1054&amp;f=png&amp;s=1272408" alt>class_replaceMethod本身会尝试调用class_addMethod和method_setImplementation，所以直接调用class_replaceMethod就可以了。  </p></li><li><h3 id="class-getInstanceMethod-amp-method-setImplementation"><a href="#class-getInstanceMethod-amp-method-setImplementation" class="headerlink" title="class_getInstanceMethod &amp; method_setImplementation"></a>class_getInstanceMethod &amp; method_setImplementation</h3></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0babfde1e81a?w=2718&amp;h=1190&amp;f=png&amp;s=1609041" alt></p><ol start="3"><li><h3 id="method-exchangeImplementations"><a href="#method-exchangeImplementations" class="headerlink" title="method_exchangeImplementations"></a>method_exchangeImplementations</h3> 心细的同学一定会发现，在这个场景下，如果直接写个OC方法然后用method_exchangeImplementations交换新旧方法的实现有问题：<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0cf5a85338cc?w=2756&amp;h=1164&amp;f=png&amp;s=1544883" alt><br>因为my_next中的self是WCAccountMainLoginViewController，调用my_next会找不到方法。解决方案是手动为WCAccountMainLoginViewController添加my_next方法。<br><img src="https://user-gold-cdn.xitu.io/2019/2/12/168e0def57b466ad?w=2742&amp;h=1118&amp;f=png&amp;s=1315641" alt><br>&emsp;由此我们也发现，method_exchangeImplementations在分类或子类中对主/父类重载的方法进行交换时更方便些，不会出现上述问题。所以在逆向中一般不直接使用method_exchangeImplementations，更倾向于前两种方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走出区块链认知的误区</title>
      <link href="/2019/01/31/%E8%B5%B0%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AE%A4%E7%9F%A5%E7%9A%84%E8%AF%AF%E5%8C%BA/"/>
      <url>/2019/01/31/%E8%B5%B0%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AE%A4%E7%9F%A5%E7%9A%84%E8%AF%AF%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>&emsp;新事物往往不是凭空而来，发展和演化也很少一蹴而就。认识新事物，首先要弄清楚它的来龙去脉，知其出身，方能知其所以然。此文章为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3llYXN5L2Jsb2NrY2hhaW5fZ3VpZGUvYmxvYi9tYXN0ZXIvU1VNTUFSWS5tZA==" title="https://github.com/yeasy/blockchain_guide/blob/master/SUMMARY.md">《区块链技术指南》<i class="fa fa-external-link"></i></span>的读后笔记&amp;摘要。</p><h3 id="账本科技的演化"><a href="#账本科技的演化" class="headerlink" title="账本科技的演化"></a>账本科技的演化</h3><p>&emsp;区块链（Blockchain）的概念首次被人们关注，源于2009年初上线的比特币（Bitcoin）开源项目。从记账科技的演化角度来看，区块链实际上是记账问题发展到分布式场景下的天然结果。账本科技的演化过程大致可以分为四个阶段：简单账本、复式账本、数字化账本、分布式账本。简单账本很好理解，就是数据没有备份，容易出错且很难发现是否被篡改过。复式账本,简单理解就是，将每笔交易分别在来源方和目标方进行记录，且多方之间的账本总额应该时刻保持相等，这样就解决了单个账本的账本可信问题。数字化账本的记账方法相对于复式账本本身并没有太多创新，但由于数字媒介的出现，使得账本的规模、处理的速度、账本的复杂度都有了天翻地覆的提升，这是现在的电子商务、互联网金融的技术基础。复式账本虽然记录了交易的来龙去脉，不易出错，但本质上仍然是中心化模式，多方交易情况下如果某个或部分账本数据出现不一致，对账十分困难，分布式账本：由交易多方共同维护同一个共享的分布式账本，打通交易在不同阶段的来龙去脉，同时凭借分布式技术进一步提高记账的规模、效率、可靠性以及合规性。但在分布式场景下，如何避免参与方恶意篡改或者破坏记录？该由谁来决定每笔交易记录是否写入到账本中？这些问题一直都还在探索最佳实践。</p><h3 id="分布式账本与区块链"><a href="#分布式账本与区块链" class="headerlink" title="分布式账本与区块链"></a>分布式账本与区块链</h3><p>&emsp;为了防止有参与者对交易记录进行篡改，需要引入一定的验证机制。很自然地，我们想到了数字摘要技术，一个多方参与且都有权限读写的账本，每次当有新的交易记录被追加到账本上时，参与各方可以使用Hash算法对完整的交易历史计算数字摘要，获取当前交易历史的“指纹”。此后任意时刻，每个参与方都可以对交易历史重新计算数字摘要，一旦发现指纹不匹配，则说明交易记录被篡改过。同时，通过追踪指纹改变位置，可以定位到被篡改的交易记录：<br><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689ede936928ce4?w=3360&amp;h=1976&amp;f=png&amp;s=398386" alt><br>&emsp;上述方案，在实际应用中可以解决记录防篡改问题，但仍然存在较大缺陷。由于每次追加新的交易记录时需要从头对所有的历史数据计算数字摘要，当已存在大量交易历史时，数字摘要计算成本将变得很高，随着新交易的放生交易耗费将越来越大，系统扩展性很差。<br>为了解决可扩展性的问题，需要进一步改进为方案二：主要到每次摘要已经确保了从头开始到摘要位置的完整历史，当新的交易发生后，实际上需要进行额外验证的只是新的交易，即增量部分。因此，计算摘要的过程可以改进为对旧的摘要值再加上新的交易内容进行验证。这样既解决了防篡改问题，又解决了可扩展性问题：<br>&emsp;实际上，你可能已经注意到，方案二的账本结构正是一个区块链结构：<br><img src="https://user-gold-cdn.xitu.io/2019/1/30/1689edec41229a91?w=3360&amp;h=1976&amp;f=png&amp;s=400395" alt><br>&emsp;可见，从分布式记账的基本问题出发，可以自然推导出区块链结构，这也说明了在分布式场景下的记账问题中，区块链是一个简洁有效的天然答案。当然，区块链结构也并非解决分布式记账问题的唯一答案，实际上，除了简单的线性队列结构，也有人提出采用树或者图结构。</p><h3 id="比特币的意义和价值"><a href="#比特币的意义和价值" class="headerlink" title="比特币的意义和价值"></a>比特币的意义和价值</h3><p>&emsp;直到今天，关于比特币的话题仍充满了不少争议。但大部分人应该都会认可，比特币是数字货币历史上，甚至整个金融历史上一次了不起的社会学实验。<br>&emsp;比特币首次真正从实践意义上实现了安全可靠的非中心化数字货币机制，这也是它受到无数金融科技从业者热捧的根本原因。作为一种概念货币，比特币主要是希望解决已有货币系统面临的几个核心问题：</p><ol><li>被掌控在单一机构手中，容易被攻击。</li><li>自身的价值无法保证，容易出现波动。</li><li>无法匿名化交易，不够隐私。<br>&emsp;要实现一套数字货币机制，最关键的还是要建立一套完善的交易记录系统，以及形成一套合理的货币发行机制。这个交易记录系统要能准确、公正地记录发生过的每一笔交易，并且无法被恶意篡改。对比已有的银行系统，可以看出，现有的银行机制作为金融交易的第三方中介机构，有代价地提供了交易记录服务。如果参与交易的多方都完全相信银行的记录（数据库），就不存在信任问题。可是如果是更大范围（甚至跨多家银行）进行流通的货币呢？哪家银行的系统能提供完全可靠不中断的服务呢？唯一可能的方案是一套分布式账本。这个账本可以被所有用户自由访问，而且任何个体都无法对所记录的数据进行恶意篡改和控制。为了实现这样一个前所未有的账本系统，比特币网络巧妙地设计了区块链结构，提供了可靠、无法被篡改的数字货币账本功能。<br>&emsp;比特币网络中，货币的发行是通过比特币协议来规定的。货币总量受到控制，发行速度随时间自动进行调整。既然总量一定，那么单个比特币的价值会随着越来越多的经济实体认可比特币而水涨船高。发行速度的自动调整则避免出现通胀或者滞涨的情况。<br>&emsp;另一方面，也要冷静地看到，作为社会学实验，比特币已经获得了某种成功，特别是基于区块链技术，已经出现了许多颇有价值的商业场景和创新技术。但这绝不意味着比特币自身必然能够进入到未来的商业体系中。比特币自身价值的波动十分剧烈；同时由于账目公开可查，通过分析仍有较大概率追踪到实际使用者；另外，比特币系统在不少管理环节上仍然依赖中心化的机制。</li></ol><h3 id="更有价值的区块链技术"><a href="#更有价值的区块链技术" class="headerlink" title="更有价值的区块链技术"></a>更有价值的区块链技术</h3><p>&emsp;如果说比特币是影响力巨大的社会学实验，那么从比特币核心设计中提炼出来的区块链技术，则让大家看到了塑造更高效、更安全的未来商业网络的可能。<br>&emsp;2014 年开始，比特币背后的区块链技术开始逐渐受到大家关注，并进一步引发了分布式记账本（Distributed Ledger）技术的革新浪潮。<br>&emsp;实际上，人们很早就意识到，记账相关的技术，对于资产（包括有形资产和无形资产）的管理（包括所有权和流通）十分关键；而多中心化的分布式记账本技术，对于当前开放、多维的商业模式意义重大。区块链的思想和结构，正是实现这种分布式记账本系统的一种极具可行潜力的技术。<br>&emsp;区块链技术现在已经从比特币项目脱颖而出，在包括金融、贸易、征信、物联网、共享经济等诸多领域崭露头角。现在，除非特别指出是“比特币区块链”，否则当人们提到“区块链技术”时，往往已与比特币没有什么必然联系了。<br>&emsp;商业行为的典型过程为：交易多方通过协商确定商业合约，通过执行合约完成交易。区块链擅长的正是如何在多方之间达成合约，并确保合约的顺利执行。根据类别和应用场景不同，区块链所体现的特点和价值也不同。从技术角度，一般认为，区块链具有如下特点：</p><ol><li>分布式容错性：分布式账本网络极其鲁棒，能够容忍部分节点的异常状态；</li><li>不可篡改性：共识提交后的数据会一直存在，不可被销毁或修改；</li><li>隐私保护性：密码学保证了数据隐私，即便数据泄露，也无法解析。</li></ol><p>随之带来的业务特性将可能包括：</p><ol><li>可信任性：区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构参与；</li><li>降低成本：跟传统技术相比，区块链技术可能通过自动化合约执行带来更快的交易，同时降低维护成本；</li><li>增强安全：区块链技术将有利于安全、可靠的审计管理和账目清算，减少犯罪风险。</li></ol><p>&emsp;区块链并非凭空诞生的新技术，更是多种技术演化到一定程度后的产物，因此，其商业应用场景也跟促生其出现的环境息息相关。对于基于数字方式的交易行为，区块链技术能潜在地降低交易成本、加快交易速度，同时能提高安全性。我认为，能否最终提高生产力，将是一项技术能否被实践接受的关键。</p><h3 id="区块链的定义与原理"><a href="#区块链的定义与原理" class="headerlink" title="区块链的定义与原理"></a>区块链的定义与原理</h3><p>讨论区块链的定义可以从狭义和广义两个层面来看待。<br>&emsp;狭义上，区块链是一种以区块为基本单位的链式数据结构，区块中利用数字摘要对之前的交易历史进行校验，适合分布式记账场景下防篡改和可扩展性的需求。<br>&emsp;广义上，区块链还指代基于区块链结构实现的分布式记账技术，包括分布式共识、隐私与安全保护、点对点通信技术、网络协议、智能合约等。<br>&emsp;区块链的基本原理理解起来并不复杂。首先来看三个基本概念：</p><ul><li><p>交易（Transaction）：一次对账本的操作，导致账本状态的一次改变，如添加一条转账记录；</p></li><li><p>区块（Block）：记录一段时间内发生的所有交易和状态结果等，是对当前账本状态的一次共识；</p></li><li><p>链（Chain）：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录。</p></li></ul><p>&emsp;如果把区块链系统作为一个状态机，则每次交易意味着一次状态改变；生成的区块，就是参与者对其中交易导致状态改变结果的共识。区块链的目标是实现一个分布的数据记录账本，这个账本只允许添加、不允许删除。账本底层的基本结构是一个线性的链表。链表由一个个“区块”串联组成（如下图所示），后继区块中记录前导区块的哈希（Hash）值。某个区块（以及块里的交易）是否合法，可通过计算哈希值的方式进行快速检验。网络中节点可以提议添加一个新的区块，但必须经过共识机制来对区块达成确认。</p><h3 id="认识上的误区"><a href="#认识上的误区" class="headerlink" title="认识上的误区"></a>认识上的误区</h3><p>目前，区块链自身仍是一种相对年轻的技术，不少人对它的认识还存在一些不足。下面总结了在探讨区块链技术时候一些常见的误区：</p><ul><li><p>区块链核心在于比特币？虽说区块链的基本思想出现在比特币设计中，但发展到今日，加密货币和区块链已经俨然成为了两个不太相关的阵营。前者侧重从金融角度发掘比特币等代币的实验性意义；后者则从技术层面探讨和研究分布式账本科技可能带来的商业价值，试图拓展到更多的场景。</p></li><li><p>区块链是一种数据库技术 虽然区块链也可以用来存储数据，但它要解决的核心问题是多方的互信协作问题。单纯从存储数据角度，区块链效率可能不高，一般也不推荐把大量原始数据直接放到区块链系统上。当然，现有区块链系统中大量使用了数据库技术。也有企业尝试将区块链技术引入到分布式数据库领域，解决非中心化的管理，如 BigchainDB。</p></li><li><p>Token 就是数字货币？ 早在区块链概念出现之前，Token（令牌）就大量应用在计算机系统中，作为带有某种权限的证明，它可以协助系统应用进行快速协作。因此，在区块链系统中使用 Token 可能在某些应用场景（如游戏积分）下提供管理便利。而数字货币则强调经济价值，跟其在系统中的原生功能无必然联系。</p></li><li><p>区块链是万能的，是颠覆性的？ 作为融合多项已有技术而出现的事物，区块链跟现有技术体系是一脉相承的。它在解决多方合作和可信处理上向前多走了一步，但并不意味着它解决了所有问题，更不会快速颠覆大量的商业模式。很长一段时间里，区块链最适用的场景仍需不断摸索，区块链也会跟已有系统共存使用。</p></li><li><p>区块链必然是非中心化的？非中心化的一定优于中心化设计？讨论技术的优劣必须要有场景前提，区块链也是如此。并不存在某种区块链技术能在任意场景下都优于其它方案，这也是为何目前公开链和联盟链在技术选型上存在较大差异。中心化设计具有设计简单，管理完善，性能可控的特点，但往往容错性能比较差；非中心化（多中心化）的设计可以提高容错性能，利用多方共识来降低篡改风险，但意味着设计较复杂，要付出性能代价。实际上，根据实际场景的需求，现有大部分区块链技术都介于绝对的中心化和绝对的非中心化之间，以取得不同指标上的平衡。例如公开链为了提高性能通过选择部分信任的节点来作为代表。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> 基本概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix/Linux文件类型与权限管理</title>
      <link href="/2019/01/27/Unix:Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2019/01/27/Unix:Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在小白与计算机的日常中，经常会碰到文件无（读、写、执行）权限，包括很多刚入门的程序员，也常常在别人的博客里会看到类似 <figure class="highlight plain"><figcaption><span>777 XX.file```、```chmod u+x XX.file```、```chmod g-w XX.file```这些不明觉厉的命令，今天来帮还不清楚的童鞋科普一下，电脑中每个文件的权限 系统究竟是如何管理的，又如何修改文件的权限。  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 看懂文件类型与权限等信息</span><br><span class="line">&amp;emsp;先不慌，打开终端，在任意非空目录下我们输入：</span><br></pre></td></tr></table></figure></p><p>ls -l<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">终端会输出该目录下所有文件的信息：</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/23/16878e2679f7e8f8?w=1210&amp;h=174&amp;f=png&amp;s=49942)</span><br><span class="line">好，我们来对每一列是什么分别介绍：</span><br><span class="line">1. -r-xr-xr-x：文件类型及权限信息  </span><br><span class="line">    我们会发现任意一个文件第一列都是一个由 - d l p s b c D r w x + @ 这些字符组成的字符串，这一串字符究竟是由哪几部分组成又分别代表什么呢？</span><br><span class="line">    * 第一位字符：文件类型信息，-代表这是一个常规文件--Regular file，d代表这是一个文件夹--Directory，l代表文件链接--Symbolic link，更多文件类型（p-Named pipe、s-Socket、b/c-Device file、D-Door）请参考[Unix file types]((https://en.wikipedia.org/wiki/Unix_file_types))</span><br><span class="line">    * 第2-10位，这九位字符每三个为一组，每组的三个字符分别代表读(r)、写(w)、执行(x)权限，三组分别代表不同所有者对该文件的权限，第一组：文件所有者的权限、第二组：这一组其他用户的权限、第三组：非本组用户的权限，总结如下图：</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/23/16878dd01879f1d6?w=2142&amp;h=796&amp;f=png&amp;s=455829)</span><br><span class="line">    * 在MacOS系统中，输入```ls -l``` 发现文件权限格式与Linux稍有不同，部分文件权限信息的末尾有”+“或”@“符号：</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/23/16878df88b3644fa?w=1110&amp;h=266&amp;f=png&amp;s=70168)</span><br><span class="line">我们直接看官方说明：终端输入```man ls```，我们可以看到这一段说明：</span><br></pre></td></tr></table></figure></p><pre><code>If the file or directory has extended attributes, the permissions field printed by the -l option is followed by a &apos;@&apos; character.  Otherwise, if the file or directory has extended security information (such as an access control list), the permissions field printed by the -l option is followed by a &apos;+&apos; character.</code></pre><p><code>那什么是“extended security”呢？其实就是扩展安全信息  执行</code>ls -le<code>查看extended security:![](https://user-gold-cdn.xitu.io/2019/1/23/16879719bf49f408?w=1506&amp;h=380&amp;f=png&amp;s=91760)你会发现权限末尾有&#39;+&#39;的都会有</code>0: group:everyone deny delete<code>`</code>，意义就很明显啦~  </p><p>那什么又是“extended attributes”呢？继续查看“@”的含义，<br>执行 <code>ls -l@</code>或<code>xattr -l XX.file</code> 查看扩展属性：<br><img src="https://user-gold-cdn.xitu.io/2019/1/23/16879748eb7b298b?w=1464&amp;h=436&amp;f=png&amp;s=113500" alt><br>简单理解@就是表示文件或目录有额外属性，比如在MacOS上 从网上下载个文件有时会提示“此文件来自网络下载不安全”，就是这个属性起的作用。而从MacOS下copy文件到Linux系统上时也会因为这个属性出现打不开的情况。可以手动去除掉：<code>xattr -c XX.file</code>。</p><ol start="2"><li>其余每一列对应的信息如下：<br><img src="https://user-gold-cdn.xitu.io/2019/1/23/1687a3e2b0a9533f?w=1008&amp;h=278&amp;f=png&amp;s=79464" alt><br>[类型+权限]—[连接]-[所有者]-[所属组]-[文件大小]-[最后修改日期]-[文件名称]</li></ol><h3 id="文件权限的修改："><a href="#文件权限的修改：" class="headerlink" title="文件权限的修改："></a>文件权限的修改：</h3><p>一张图看懂修改文件权限的命令：<br><img src="https://user-gold-cdn.xitu.io/2019/1/23/1687a446f2bd8e5e?w=2136&amp;h=814&amp;f=png&amp;s=281716" alt><br>通过按位与的设计巧妙的用三个二进制位表示了三种权限产生的8种组合。<br>用符号改变权限时，如：<code>chmod a+r XX.file</code>表示对用户、组、其他 全部添加读取权限。</p><p>以上，有任何疑问欢迎留言~</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
          <category> 文件管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
            <tag> 文件权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>撸一个 iOS 重签名脚本</title>
      <link href="/2019/01/23/%E6%92%B8%E4%B8%80%E4%B8%AAiOS%E9%87%8D%E7%AD%BE%E5%90%8D%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/01/23/%E6%92%B8%E4%B8%80%E4%B8%AAiOS%E9%87%8D%E7%AD%BE%E5%90%8D%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>上一篇<a href="https://enjoycoding007.github.io/2019/01/21/iOS%20APP%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">iOS APP签名详解</a>我们了解了iOS签名的机制和原理，这一篇我们一起来动手写一个自动重签名的脚本，懒是程序员乃至人类进步的终极力量，造轮子写工具可以极大的避免重复性工作，为我们节省更多的时间放在思考上，话不多说撸起袖子开始干：  </p><h3 id="第一步：获取脱壳的ipa包"><a href="#第一步：获取脱壳的ipa包" class="headerlink" title="第一步：获取脱壳的ipa包"></a>第一步：获取脱壳的ipa包</h3><ol><li>从iTunes 12.6.3及以前的版本上直接下载 （macOS Mojave Doesn’t Support），这样获取到的是正版ipa，需要用Clutch、dumdecrypted等工具先脱壳，否则别人的加密验证不通过无法安装</li><li>各类助手上下载越狱版ipa包</li><li>越狱手机导出</li><li>Xcode打包 等等</li></ol><p>这里我下载了微信的越狱版ipa包用来演示。</p><h3 id="第二步：命令行实现重签名"><a href="#第二步：命令行实现重签名" class="headerlink" title="第二步：命令行实现重签名"></a>第二步：命令行实现重签名</h3><ol><li><p>将ipa解压缩后前往.app所在目录，输入  </p> <figure class="highlight plain"><figcaption><span>-d -vv WeChat.app```  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">查看可执行文件的签名信息：</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/22/1687194244bf3be8?w=1424&amp;h=376&amp;f=png&amp;s=245630)</span><br><span class="line">可以看到签名信息现在还是腾讯的  </span><br><span class="line"></span><br><span class="line">2. 输入：  </span><br><span class="line">```security find-identity -v -p codesigning```  </span><br><span class="line">查看Mac本地的证书列表:</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/22/16871950dcd0e283?w=1592&amp;h=272&amp;f=png&amp;s=114415)</span><br><span class="line">记下你要用来签名的证书双引号（包括双引号）中的字符串，一会儿会用到  </span><br><span class="line"></span><br><span class="line">3. 确认ipa包是否已经脱壳，输入：  </span><br><span class="line">```cd WeChat.app```  </span><br><span class="line">```otool -l WeChat | grep crypt```  </span><br><span class="line">会输出：![](https://user-gold-cdn.xitu.io/2019/1/22/16871958f396421c?w=988&amp;h=244&amp;f=png&amp;s=94527)</span><br><span class="line">cryptid为0即为已脱壳，为1为加密状态。这里有两组数据是因为这是个支持两种CPU架构的可执行文件，可输入```file WeChat```查看可执行文件支持的架构：</span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/22/16871961777d44a5?w=1396&amp;h=142&amp;f=png&amp;s=108757)</span><br><span class="line">4. 删除无法签名的插件文件：PlugIns文件夹、Watch文件夹  </span><br><span class="line">5. 对.app文件夹内的Frameworks文件夹中的每一个framework强制重签名：</span><br><span class="line">```codesign -fs 步骤2中记下的证书信息 要签名的.framework```  </span><br><span class="line">注意不要遗漏，每一个framework都要用自己的证书重签一下</span><br><span class="line">6. 将自己的描述文件名改为embedded.mobileprovision，并拖入到.app中，再将.app中info.plist文件里的Bundle identifier改成我们自己的BundleID</span><br><span class="line">7. 在.app同级目录下新建一个entitlements.plist文件，查看描述文件内容：  </span><br><span class="line">    ```security cms -D -i embedded.mobileprovision```将Entitlements节点下的</span><br></pre></td></tr></table></figure><p> <dict></dict></p><pre><code>......</code></pre><p>   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    复制粘贴到刚刚新建的entitlements.plist文件中</span><br><span class="line">8. 最后一步，对整个包签名，回到.app所在目录，输入：</span><br><span class="line">    ```codesign -fs 步骤2中记下的证书信息 --no-strict --entitlements=entitlements.plist WeChat.app```  </span><br><span class="line">    签名成功！</span><br><span class="line">9. 打包：```zip -ry WeiChat.ipa Payload</span><br></pre></td></tr></table></figure></li></ol><p>以上，就是通过命令行一步步的实现应用重签名。</p><h3 id="最后：撸自动重签名的脚本"><a href="#最后：撸自动重签名的脚本" class="headerlink" title="最后：撸自动重签名的脚本"></a>最后：撸自动重签名的脚本</h3><p>现在我就按照这个思路写脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#$&#123;SRCROOT&#125; 它是工程文件所在的目录</span><br><span class="line">TEMP_PATH=&quot;$&#123;SRCROOT&#125;/Temp&quot;</span><br><span class="line">#资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包</span><br><span class="line">ASSETS_PATH=&quot;$&#123;SRCROOT&#125;/APP&quot;</span><br><span class="line">#目标ipa包路径</span><br><span class="line">TARGET_IPA_PATH=&quot;$&#123;ASSETS_PATH&#125;/*.ipa&quot;</span><br><span class="line">#清空Temp文件夹</span><br><span class="line">rm -rf &quot;$&#123;SRCROOT&#125;/Temp&quot;</span><br><span class="line">mkdir -p &quot;$&#123;SRCROOT&#125;/Temp&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># 1. 解压IPA到Temp下</span><br><span class="line">unzip -oqq &quot;$TARGET_IPA_PATH&quot; -d &quot;$TEMP_PATH&quot;</span><br><span class="line"># 拿到解压的临时的APP的路径</span><br><span class="line">TEMP_APP_PATH=$(set -- &quot;$TEMP_PATH/Payload/&quot;*.app;echo &quot;$1&quot;)</span><br><span class="line"># echo &quot;路径是:$TEMP_APP_PATH&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># 2. 将解压出来的.app拷贝进入工程下</span><br><span class="line"># BUILT_PRODUCTS_DIR 工程生成的APP包的路径</span><br><span class="line"># TARGET_NAME target名称</span><br><span class="line">TARGET_APP_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app&quot;</span><br><span class="line">echo &quot;app路径:$TARGET_APP_PATH&quot;</span><br><span class="line"></span><br><span class="line">rm -rf &quot;$TARGET_APP_PATH&quot;</span><br><span class="line">mkdir -p &quot;$TARGET_APP_PATH&quot;</span><br><span class="line">cp -rf &quot;$TEMP_APP_PATH/&quot; &quot;$TARGET_APP_PATH&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># 3. 删除extension和WatchAPP.个人证书没法签名Extention</span><br><span class="line">rm -rf &quot;$TARGET_APP_PATH/PlugIns&quot;</span><br><span class="line">rm -rf &quot;$TARGET_APP_PATH/Watch&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># 4. 更新info.plist文件 CFBundleIdentifier</span><br><span class="line">#  设置:&quot;Set : KEY Value&quot; &quot;目标文件路径&quot;</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># 5. 给MachO文件上执行权限</span><br><span class="line"># 拿到MachO文件的路径</span><br><span class="line">APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`</span><br><span class="line">#上可执行权限</span><br><span class="line">chmod +x &quot;$TARGET_APP_PATH/$APP_BINARY&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># 6. 重签名第三方 FrameWorks</span><br><span class="line">TARGET_APP_FRAMEWORKS_PATH=&quot;$TARGET_APP_PATH/Frameworks&quot;</span><br><span class="line">if [ -d &quot;$TARGET_APP_FRAMEWORKS_PATH&quot; ];</span><br><span class="line">then</span><br><span class="line">for FRAMEWORK in &quot;$TARGET_APP_FRAMEWORKS_PATH/&quot;*</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">#签名</span><br><span class="line">/usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$FRAMEWORK&quot;</span><br><span class="line">done</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><ul><li>将写好的脚本直接丢到.xcodeproj同级目录中</li><li>Xcode –&gt; Build Phases –&gt; New Run Script Phase:<br><img src="https://user-gold-cdn.xitu.io/2019/1/22/16871b154fd4fd26?w=1114&amp;h=590&amp;f=png&amp;s=68151" alt></li><li>现在，将你要重签名的ipa包丢到在工程目录下新建的文件夹APP中（这个文件夹跟你写的脚本中的目标文件夹同名即可），直接Run！任何应用都会在你的真机上跑起来了！这也是后面讲逆向的准备工作。</li></ul><h4 id="了解了iOS签名的原理再做重签名，我相信上面的每一步为什么那么做，你自然也很清楚了，写起脚本来自然思路也很清晰-如果你在实践中遇到任何问题，欢迎留言交流"><a href="#了解了iOS签名的原理再做重签名，我相信上面的每一步为什么那么做，你自然也很清楚了，写起脚本来自然思路也很清晰-如果你在实践中遇到任何问题，欢迎留言交流" class="headerlink" title="了解了iOS签名的原理再做重签名，我相信上面的每一步为什么那么做，你自然也很清楚了，写起脚本来自然思路也很清晰~如果你在实践中遇到任何问题，欢迎留言交流~"></a>了解了iOS签名的原理再做重签名，我相信上面的每一步为什么那么做，你自然也很清楚了，写起脚本来自然思路也很清晰~如果你在实践中遇到任何问题，欢迎留言交流~</h4>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 应用签名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS APP签名机制详解</title>
      <link href="/2019/01/18/iOS%20APP%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/01/18/iOS%20APP%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="苹果的需求"><a href="#苹果的需求" class="headerlink" title="苹果的需求"></a>苹果的需求</h3><ol><li>为了保证系统的安全性，所有iPhone上安装的应用必须是经过苹果授权的</li><li>安装包不需要上传到App Store也能被安装 （开发调试 企业灰度）</li><li>防止证书权限滥用：设备限制、指定APP、iCloud/PUSH/后台运行等附加权限控制</li></ol><p>苹果的解决方案：<strong>双层代码签名+描述文件:</strong></p><p>这里画一张图附上：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/21/16870efe0c1b7b07?w=2112&amp;h=1138&amp;f=png&amp;s=444176" alt><br>&emsp;在iOS出来之前，主流的操作系统（MacOS/Windows）软件随便从哪里下载都能运行，系统安全存在隐患，盗版软件、病毒入侵、静默安装等等，苹果希望解决类似的问题，保证在iPhone iOS上的APP都是经过苹果官方允许的，怎样保证呢？就是通过<strong>代码签名</strong>。  </p><p>&emsp;如果要实现验证，最简单的方式就是苹果官方生成一对RSA公私钥，在iOS系统中内置一个公钥，私钥由苹果后台保存，我们上传APP到App Store时苹果后台用私钥对APP数据进行加密，iPhone下载APP后用公钥验证这个签名就可以确认APP是否经过允许或被三方篡改过。但是，我们安装APP并不仅仅只有App Store这一个方式，比如真机调试、企业包等，所以只靠这个简单的数字签名方式是不够的。  </p><p>&emsp;于是苹果设计了双层签名的机制，我们都知道iOS的应用开发必须在Mac系统下进行，正是由于这个依赖关系，双层签名才有了基础：  </p><ol><li>在Mac系统中生成一对非对称加密算法的公私钥M（Xcode会帮你做好）  </li><li>苹果自己有固定的一对公私钥，正如上述最简单的代码签名中提到的：私钥A在苹果后台，公钥A在每个iOS系统的手机中  </li><li>把公钥M以及一些开发者信息（也就是CSR文件）发送给苹果后台，用苹果后台的私钥A对公钥M签名，得到一份包含公钥M以及其签名结果的数据就是证书（.p12）。  </li><li>在开发时，当我们打包时会用本地的私钥M（也就是可导出给小伙伴的开发者证书）对这个APP进行签名，同时把第三步得到的证书一起打包进APP里，然后安装到手机上（真机联调）或者提交App Store审核  </li><li>安装时，iOS系统取得内置公钥A去验证公钥M的数字签名证书是否正确  </li><li>验证公钥M是苹果认证过的后，再用公钥M去验证APP的签名，这样就间接验证了这个APP的安装是经过苹果允许的了（注意这里只验证安装行为，不验证APP是否被改动，因为开发阶段APP内容总是不断变化的）</li></ol><p>&emsp;有了上面的过程已经可以保证开发者的认证和程序的安全了，但是如果只有上述的过程，那岂不是只要申请了一个证书就可以安装到所有的iOS设备了？所以，苹果又增加了授权文件（Provisioning profile）的验证，Provisioning profile一般包括三样东西：证书、APP ID、设备。  </p><p>&emsp;描述文件是在AppleDevelop网站创建的(在Xcode中填上AppleID它会代办创建)，Xcode运行时会打包进入APP内。在开发时，编译完一个 APP 后，用本地的私钥M对这个APP进行签名，同时把从苹果服务器得到的 Provisioning Profile 文件打包进APP里，文件名为embedded.mobileprovision，当把APP安装到手机上时，iOS系统会进行验证。  </p><p>&emsp;以上就是iOS应用签名的原理，下一篇基于这个原理我会手撸一个自动重签名的脚本。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 应用签名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈iOS中常用加密算法的使用</title>
      <link href="/2019/01/12/%E6%B5%85%E8%B0%88iOS%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/12/%E6%B5%85%E8%B0%88iOS%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>&emsp;以前如果我们忘记了登录密码，通常可以通过“找回密码”这样的方式拿回密码，那说明你的隐私数据在他们的数据库中是明文保存的，现在请切记：如果哪个平台还有这样的方式请立刻马上注销你的账号，并避免在任何其他平台使用这个平台使用过的密码。请坚信：在网络世界中，只要是明文存在或可逆的东西，都是不安全的。没有哪家公司会告诉你他们的数据库被拖库过，你更无法想象现在的黑色产业早已让你毫无隐私。 </p><p>&emsp;千万别一个密码走天下，一定要定期改密码！ </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/12/16842539835b86d2" alt><br>&emsp;道高一尺魔高一丈，对用户隐私及一些敏感数据的保护越来越重要，在iOS中，苹果封装了Security.framework、CommonCrypto.framework这两个保护信息安全的库，为我们提供了安全相关的通用API：  </p><ul><li>RSA：公私钥的生成、公钥加密、私钥解密、私钥签名、公钥验签功能，证书信息的读取，以及密钥在KeyChain中存储，查找，删除等功能  </li><li>哈希：SHA1、SHA224、SHA256、SHA384、SHA512<br>MD2、MD4、MD5   </li><li>对称加密：DES、3DES、AES  </li></ul><p>&emsp;这一篇文章，我们就以“用户输入密码，登录，服务端验证用户信息，用户上传隐私数据”这个常见场景为例，分享一些密码学常识和加密时常用的防破解技巧，至于上述算法相关API的使用，文末我会附上iOS中所有常用加密API使用的demo，这里就不浪费篇幅贴代码了。先说两个保护用户隐私的原则： </p><ul><li>网络上不允许明文传递用户隐私信息</li><li>本地不允许明文保存用户隐私信息</li></ul><p>&emsp;再了解下几种算法的特点：</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul><li>加密解密共用一个密钥</li><li>DES 数据加密标准，安全强度不够已经很少用了</li><li>3DES 使用三个密钥对相同的数据执行三次加密 强度略高，但密钥的保护一直是个隐患所以也不常用</li><li>AES 高级密码标准 用得最多</li><li>两种常用加密模式：<ul><li>ECB：<br>&emsp;最基本的加密方式，无初始向量，相同的明文永远生成不变的密文，容易受到密码本重放攻击，很少用</li><li>CBC：<br>&emsp;明文被加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。<br>&emsp;可以有效的保证密文的完整性，如果一个数据块在传递是丢失或改变，后面的数据将无法正常解密。  <h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4>关于RSA相关知识请参考：<br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzMzNWNkNWYyNjVkYTYxNTMwNGVlOTg=" title="https://juejin.im/post/5c335cd5f265da615304ee98">非对称加密–RSA原理浅析<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzM0YTcxYWYyNjVkYTYxMzA3NTBkNjA=" title="https://juejin.im/post/5c34a71af265da6130750d60">RSA的主场-证书签名之OpenSSL演示<i class="fa fa-external-link"></i></span>  </li></ul></li></ul><p>这里不再赘述。</p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>也就是常说的散列函数，严格意义上它并不是一种加密算法，但它常常与加密算法一起出现，作为一种组合方式。哈希具有以下特点：  </p><ul><li>算法是公开的</li><li>对相同的数据运算，得到的结果是一样的</li><li>同一算法对不同的数据运算，得到的结果长度是固定的，如MD5的结果一定是128bit，32个字符(16进制表示)，所以散列碰撞是必然的偶然</li><li>不可逆，但是可以通过<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJEJUE5JUU4JTk5JUI5JUU4JUExJUE4" title="https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8">彩虹表<i class="fa fa-external-link"></i></span>去<span class="exturl" data-url="aHR0cHM6Ly93d3cuY21kNS5jb20v" title="https://www.cmd5.com/">反查询<i class="fa fa-external-link"></i></span></li><li><p>通常作为信息“指纹”–信息摘要，用来做数据识别（版权、搜索引擎、数字签名等）。</p><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>&emsp;知道了每种算法的特点，回到应用场景：用户输完密码点击登录时，我们如何保证用户信息是足够安全的呢？</p></li><li><p>对称加密：密钥传输有隐患，且在客户端加密前和服务端解密后会出现明文，不安全。</p></li><li>RSA：安全性高，网络劫持很难破解，但是服务端拿到客户端加密后的密文怎么办呢？用私钥解密，解密之后拿到明文信息？大忌，没有哪个服务端是安全的，更没法保证数据库人员的个人泄露用户信息。不可取。</li><li>哈希：  <ul><li>直接MD5？用户输入常规组合概率很大，暴力破解风险很高，不可取。本地加盐，很变态的盐？安全性有一定保障，缺点是盐写死在程序里了，写代码的人也有泄露的可能性，一旦泄漏结果是毁灭性的，不可取。</li><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9obWFj" title="https://baike.baidu.com/item/hmac">HMAC<i class="fa fa-external-link"></i></span>：Keyed-Hashing for Message Authentication，这是一种使用单向散列函数来构造消息认证码的方案，而不是算法。<br>&emsp; 在第一次注册时，服务端下发一个随机密钥 n，这个密钥会在客户端和服务端都保存一份（支持服务端更新），客户端的 n 用作以后每次登录时的“盐”参与第一次散列运算，并将第一次散列运算的结果 s 发给服务端作为用户密码信息保存到数据库中，这样用户的真实密码无论是客户端还是服务端都不知道，也不存在数据库被拖库泄露的问题。服务端保存的 n 用于当用户换设备登录或卸载重新装时验证通过后再次将 n 下发给客户端保存。<br>&emsp;用户每次登录时，服务器会再动态下发一个随机值作为密钥，并在会话中记下这个随机值 r，客户端先用本地保存的 n 对用户密码做散列运算得到 s ，再用 r 对 s 做一次<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NQUMlRTclQUUlOTclRTYlQjMlOTUvMjI2NDM2Mg==" title="https://baike.baidu.com/item/MAC%E7%AE%97%E6%B3%95/2264362">MAC<i class="fa fa-external-link"></i></span>（Message Authentication Codes）运算并将运算结果发送给服务端，服务端也从数据库中取出用户的密码散列值做同样的运算，并将结果与客户端进行对比。为了防止网络中间人攻击，还需将时间戳（服务器时间，一般精确到分钟）参与校验，黑客就很难破解了。这是目前最主流的安全方案。</li></ul></li></ul><p>&emsp;现在用户登录成功，现在要上传一份敏感数据，我们如何保证数据的完整性呢？结合上面的分析，推荐AES的CBC加密方式，安全性高，还能保证完整性，数字签名同样也可以验证数据完整性，用RSA对数据的hash值进行加密，服务端接收完数据后，用私钥解密得到hash值，与接收数据的hash值作比对。  </p><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>iOS中常见加密算法的使用：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vuam95SW5Db2RpbmdBbHdheXMvRW5jcnlwdERlbW8uZ2l0" title="https://github.com/EnjoyInCodingAlways/EncryptDemo.git">EncryptDemo<i class="fa fa-external-link"></i></span><br>在Demo中，对称加密AES的加密解密函数：  </p><pre><code>CCCryptorStatus CCCrypt(    CCOperation op,         /* kCCEncrypt, etc. */    CCAlgorithm alg,        /* kCCAlgorithmAES128, etc. */    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */    const void *key,    size_t keyLength,    const void *iv,         /* optional initialization vector */    const void *dataIn,     /* optional per op and alg */    size_t dataInLength,    void *dataOut,          /* data RETURNED here */    size_t dataOutAvailable,    size_t *dataOutMoved)    API_AVAILABLE(macos(10.4), ios(2.0));  </code></pre><p>调用CCCrypt时，用户敏感数据不要直接作为参数传递，否则逆向很容易hook到，通常的做法是对敏感数据做异或、加盐等处理，具体根据需要自己设计。  </p><p>iOS app签名机制详解 推荐阅读：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wMjAzNGQxYTkxYjU=" title="https://www.jianshu.com/p/02034d1a91b5">iOS应用签名(上)<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zYzllMjA1NWFlNWI=" title="https://www.jianshu.com/p/3c9e2055ae5b">iOS应用签名(下)<i class="fa fa-external-link"></i></span></p><p>iOS中对钥匙串的操作推荐：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbXNvZmZlcy9zc2tleWNoYWlu" title="https://github.com/samsoffes/sskeychain">SSKeyChain<i class="fa fa-external-link"></i></span>  </p><h4 id="实践出真知，下篇再会"><a href="#实践出真知，下篇再会" class="headerlink" title="实践出真知，下篇再会~"></a>实践出真知，下篇再会~</h4><p>老规矩，有错误请积极指正，有问题请踊跃留言。</p><p>更多一手好文更新，请关注我的个人微信公众号：面向未来编程  </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA的主场-证书签名&amp;OpenSSL演示</title>
      <link href="/2019/01/09/RSA%E7%9A%84%E4%B8%BB%E5%9C%BA-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D&amp;OpenSSL%E6%BC%94%E7%A4%BA/"/>
      <url>/2019/01/09/RSA%E7%9A%84%E4%B8%BB%E5%9C%BA-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D&amp;OpenSSL%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在上一篇<a href="https://enjoycoding007.github.io/2019/01/07/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86--RSA%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/">非对称加密–RSA原理浅析</a>中，我们了解了RSA加密的数学原理，RSA的安全性目前虽然得到公认，但它同样也有缺点：加密速度慢、性能较低，不适合对大文件直接做加密，需要加密的原始数据通常会先经过<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0" title="https://zh.wikipedia.org/wiki/Base64">Base64<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk1JUEzJUU1JTg4JTk3JUU1JTg3JUJEJUU2JTk1JUI4" title="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">Hash<i class="fa fa-external-link"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThEJUU3JUE4JUIxJUU1JUFGJTg2JUU5JTkxJUIwJUU1JThBJUEwJUU1JUFGJTg2" title="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称加密<i class="fa fa-external-link"></i></span>等处理后，再用RSA对其进行加密，因此<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUlNBJUU1JThBJUEwJUU1JUFGJTg2JUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA<i class="fa fa-external-link"></i></span>最主要的应用场景，是数字签名–对数据做身份/合法性校验。<br>&emsp;权威的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFGJTgxJUU0JUI5JUE2JUU5JUEyJTgxJUU1JThGJTkxJUU2JTlDJUJBJUU2JTlFJTg0" title="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构<i class="fa fa-external-link"></i></span>–躺着赚钱的CA，就是用的RSA这一套算法，这一篇我们一起用命令行来逐步拆解证书的生成过程，揭开证书背后的秘密。Talk is cheap，show you the code，Come on！</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/9/168318e5e48e3cb3?w=1200&amp;h=326&amp;f=png&amp;s=117690" alt></p><h4 id="什么是OpenSSL"><a href="#什么是OpenSSL" class="headerlink" title="什么是OpenSSL"></a>什么是OpenSSL</h4><p>&emsp;SSL大家都不陌生，我们访问网站的时候，以HTTPS开头的表示你和服务器之间传输的数据经过了加密，这里所使用的加密协议就是SSL（Secure Sockets Layer，后来又推出了它的后续版本，改名叫TLS）。也就是说，把HTTP协议经过一层SSL协议进行加密包装，就变成了HTTPS。当然，SSL/TLS还用在很多协议中，例如VPN、加密的电子邮件协议等。<br>&emsp;那OpenSSL是啥？在SSL协议中，我们使用了很多密码学手段来保护数据，其中包括对称密码、公钥密码、数字签名、证书、完整性校验、伪随机数生成等。由于这些算法和操作都非常复杂，于是开源社区就开发了一套库，这个库里面提供了很多现成的标准方法，其他开发者只要用正确调用这些方法，就可以实现SSL协议中的各种加密/解密操作了。因此，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvT3BlblNTTA==" title="https://zh.wikipedia.org/wiki/OpenSSL">OpenSSL<i class="fa fa-external-link"></i></span>是一套开源的密码学工具包（open source cryptography toolkit）。情理之中的，OpenSSL也支持了RSA算法，接下来我们就用OpenSSL在macOS的终端上为大家演示证书签名的每一个步骤。</p><h4 id="RSA加密、证书生成终端演示"><a href="#RSA加密、证书生成终端演示" class="headerlink" title="RSA加密、证书生成终端演示"></a>RSA加密、证书生成终端演示</h4><p>&emsp;为了便于观察，请开辟并前往一个空文件夹下开始你的表演~<br>输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private.pem 2048</span><br><span class="line">```  </span><br><span class="line">此时目录中出现一个private.pem文件，这个文件包含了私钥信息  </span><br><span class="line">根据私钥生成公钥  </span><br><span class="line">输入：</span><br></pre></td></tr></table></figure></p><p>openssl rsa -in private.pem -pubout -out public.pem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分别查看文件中的内容：</span><br></pre></td></tr></table></figure></p><p>cat private.pem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">cat public.pem</span><br><span class="line">```  </span><br><span class="line">你会得到这样类似这样的结果：</span><br></pre></td></tr></table></figure></p><p>—–BEGIN RSA PRIVATE KEY—–<br>Base64编码的内容<br>—–END RSA PRIVATE KEY—–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">Base64编码的内容</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">```  </span><br><span class="line">现在我们随便写一个txt文件作为要加密的数据：</span><br></pre></td></tr></table></figure></p><p>echo “hello word!“ &gt; message.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用公钥对其加密：</span><br></pre></td></tr></table></figure></p><p>openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看加密后的文件：```cat enc.txt```，你只能看到一堆乱码  </span><br><span class="line">用私钥对加密文件解密：</span><br></pre></td></tr></table></figure></p><p>openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看解密结果：```cat dec.txt```，与你的message.txt内容完美吻合~  </span><br><span class="line">上面的过程反过来（私钥加密 公钥解密）一个道理，但执行命令有点区别：  </span><br><span class="line">用私钥对其加密：</span><br></pre></td></tr></table></figure></p><p>openssl rsautl -sign -in message.txt -inkey private.pem -out enc.bat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用公钥对加密文件解密：</span><br></pre></td></tr></table></figure></p><p>openssl rsautl -verify -in enc.bat -inkey public.pem -pubin -out dec.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;至此，我们已经完成了RSA加密解密的操作，那我们开发中用的证书跟它们有什么关系呢？做iOS开发的都用钥匙串从CA请求过csr文件，其实就是根据当前Mac内置的私钥（当然你也可以自己指定私钥）生成对应的公钥，生成的csr文件包含了公钥证书原始文件+你的服务器信息和单位等信息。我们来用命令执行这一步操作：</span><br></pre></td></tr></table></figure></p><p>openssl req -new -key private.pem -out rsacert.csr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据提示依次输入下列信息并回车:</span><br></pre></td></tr></table></figure></p><p>Country Name (2 letter code) []:<br>State or Province Name (full name) []:<br>Locality Name (eg, city) []:<br>Organization Name (eg, company) []:<br>Organizational Unit Name (eg, section) []:<br>Common Name (eg, fully qualified host name) []:<br>Email Address []:<br>A challenge password []:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拿到带着公钥信息的csr文件之后，下一步就是交给CA认证中心进行签名，也就是让CA盖个章（一个章一年五千大洋@_@，如果你的https用自签的证书那别人访问时有不安全提示就是因为你没有CA盖的这个章，不被承认是安全的）：</span><br></pre></td></tr></table></figure></p><p>openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这时得到的crt文件是Base64编码的，我们需要转成DER二进制格式的证书才能直接使用：</span><br></pre></td></tr></table></figure></p><p>openssl x509 -outform der -in rsacert.crt -out rsacert.der<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个rsacert.der文件就是包含了我们公钥信息的证书！  </span><br><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/9/16832dfe1997dfd0?w=1022&amp;h=826&amp;f=png&amp;s=172453)</span><br><span class="line">最后一步，导出公钥证书对应的私钥证书：</span><br></pre></td></tr></table></figure></p><p>openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![](https://user-gold-cdn.xitu.io/2019/1/9/16832e25c325de5f?w=1004&amp;h=816&amp;f=png&amp;s=165762)</span><br><span class="line">输入两次私钥证书的密码就得到了我们最熟悉的.p12文件。  </span><br><span class="line">&amp;emsp;当然，在我们实际开发中不会同时拿到这两个证书，这里只是给大家演示它们之间的关系，后面我会对苹果的双向验证(双层签名)原理专门写一篇文章讲解  </span><br><span class="line">### 补充</span><br><span class="line">&amp;emsp;关于.pem文件内部的数据结构可以通过命令</span><br></pre></td></tr></table></figure></p><p>openssl rsa -in private.pem -text -out ptivate.txt<br><code>`</code><br>查看，ptivate.txt文件中每一项的具体意义请参考<span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzRmY2QxZWEzMDEwMHloNHMuaHRtbA==" title="http://blog.sina.com.cn/s/blog_4fcd1ea30100yh4s.html">（PEM格式）解析<i class="fa fa-external-link"></i></span><br>&emsp;在上面的命令中如果有些不明觉厉的玩意儿，那多半是你对证书相关的文件编码格式、协议和扩展名不太熟悉，不要慌，我已经为你准备好了加餐。</p><h4 id="高能预警——证书文件编码格式、扩展名、协议科普"><a href="#高能预警——证书文件编码格式、扩展名、协议科普" class="headerlink" title="高能预警——证书文件编码格式、扩展名、协议科普"></a>高能预警——证书文件编码格式、扩展名、协议科普</h4><p>&emsp;我们统一采用<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvWC41MDk=" title="https://zh.wikipedia.org/wiki/X.509">X.509<i class="fa fa-external-link"></i></span>的格式标准生成证书，接触过证书的同学看到：pem、der、pfx、jks、kdb、cer、key、csr、crt、crl、ocsp、scep等这些字眼一定不会完全陌生，这些东东究竟是个啥？赶紧来一探究竟，有描述不准确的地方还望指正：</p><ul><li>编码格式<ul><li>DER：（Distinguished Encoding Rules）的缩写，它是大多数浏览器的缺省格式，并按 ASN1 DER 格式存储，它是无报头的。可包含所有私钥、公钥和证书。</li><li>PEM：（Privacy Enhanced Mail）的缩写，它是OpenSSL默认采用的信息存放方式，它存储用Base64编码的DER格式数据，用ASCII报头包围，因此适合系统之间的文本模式传输。可以包括所有私钥、公钥和证书。</li></ul></li><li>文件扩展名<ul><li>.pem - (隐私增强型电子邮件) DER编码的证书再进行Base64编码的数据存放在”—–BEGIN CERTIFICATE—–”和”—–END CERTIFICATE—–”之中</li><li>.cer, .crt, .der - 通常是DER二进制格式的证书，但Base64编码后也很常见</li><li>.p7b, .p7c - PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)，加密消息语法(pkcs7),是各种消息存放的格式标准。这些消息包括:数据、签名数据、数字信封、签名数字信封、摘要数据和加密数据。</li><li>.p12 - PKCS#12格式，包含证书的同时可能还有带密码保护的私钥</li><li>.pfx - PFX，PKCS#12之前的格式（通常用PKCS#12格式，比如那些由IIS产生的PFX文件）</li><li>.jks - 通常可以将Apache/OpenSSL使用的“.key文件 + .crt文件”格式转换为标准的Java Key Store(JKS)文件。JKS文件格式被广泛的应用在基于JAVA的WEB服务器、应用服务器、中间件。你可以将JKS文件导入到TOMCAT、WEBLOGIC 等软件</li><li>.kdb - 通常可以将Apache/OpenSSL使用的“.key文件 + .crt文件”格式转换为标准的IBM KDB文件。KDB文件格式被广泛的应用在IBM的WEB服务器、应用服务器、中间件。你可以将KDB文件导入到IBM HTTP Server、IBM Websphere 等软件</li><li>.csr - 证书请求文件(Certificate Signing Request)。生成X509数字证书前,一般先由用户提交证书申请文件,然后由 CA 来签发证书。</li><li>.key - 一般指PEM格式的私钥文件，也可能是DER格式的</li><li>.crl - 证书吊销列表 (Certification Revocation List)是一种包含撤销的证书列表的签名数据结构。CRL是证书撤销状态的公布形式,CRL 就像信用卡的黑名单,用于公布某些数字证书不再有效。CRL是一种离线的证书状态信息。它以一定的周期进行更新。CRL可以分为完全CRL和增量CRL。在完全CRL中包含了所有的被撤销证书信息,增量CRL由一系列的CRL来表明被撤销的证书信息,它每次发布的CRL是对前面发布CRL的增量扩充。基本的CRL信息有:被撤销证书序列号、撤销时间、撤销原因、签名者以及 CRL 签名等信息。基于CRL的验证是一种不严格的证书认证。CRL能证明在CRL中被撤销的证书是无效的。但是,它不能给出不在CRL中的证书的状态。如果执行严格的认证,需要采用在线方式进行认证,即<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlDJUE4JUU3JUJBJUJGJUU4JUFGJTgxJUU0JUI5JUE2JUU3JThBJUI2JUU2JTgwJTgxJUU1JThEJThGJUU4JUFFJUFF" title="https://zh.wikipedia.org/wiki/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE">OCSP<i class="fa fa-external-link"></i></span>认证。一般是由CA签名的一组电子文档，包括了被废除证书的唯一标识（证书序列号），CRL用来列出已经过期或废除的数字证书。它每隔一段时间就会更新，因此必须定期下载该清单，才会取得最新信息</li></ul></li><li>协议<ul><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlDJUE4JUU3JUJBJUJGJUU4JUFGJTgxJUU0JUI5JUE2JUU3JThBJUI2JUU2JTgwJTgxJUU1JThEJThGJUU4JUFFJUFF" title="https://zh.wikipedia.org/wiki/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE">OCSP<i class="fa fa-external-link"></i></span> – 在线证书状态协议(Online Certificate Status Protocol,rfc2560)，用于实时表明证书状态。OCSP 客户端通过查询 OCSP 服务来确定一个证书的状态,可以提供给使用者一个或多个数字证书的有效性资料，它建立一个可实时响应的机制，让用户可以实时确认每一张证书的有效性，解决由CRL引发的安全问题。。OCSP 可以通过 HTTP协议来实现。rfc2560 定义了 OCSP 客户端和服务端的消息格式</li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2ltcGxlX0NlcnRpZmljYXRlX0Vucm9sbG1lbnRfUHJvdG9jb2w=" title="https://en.wikipedia.org/wiki/Simple_Certificate_Enrollment_Protocol">SCEP<i class="fa fa-external-link"></i></span> － 简单证书注册协议（Simple Certificate Enrollment Protocol），基于文件的证书登记方式需要从您的本地计算机将文本文件复制和粘贴到证书发布中心，和从证书发布中心复制和粘贴到您的本地计算机。SCEP可以自动处理这个过程但是CRLs仍然需要手动的在本地计算机和CA发布中心之间进行复制和粘贴</li></ul></li></ul><h4 id="实践出真知，下篇再会-老规矩，有问题请踊跃留言。"><a href="#实践出真知，下篇再会-老规矩，有问题请踊跃留言。" class="headerlink" title="实践出真知，下篇再会~ 老规矩，有问题请踊跃留言。"></a>实践出真知，下篇再会~ 老规矩，有问题请踊跃留言。</h4><p>更多一手好文更新<br>请关注我的个人微信公众号：面向未来编程 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 应用签名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非对称加密--RSA原理浅析</title>
      <link href="/2019/01/07/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86--RSA%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/2019/01/07/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86--RSA%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h3><p>&emsp;在1976年以前，所有的加密方法都是同一种模式：加密、解密使用同一种算法。在交互数据的时候，彼此通信的双方就必须将规则告诉对方，否则没法解密。这种加密与解密使用同一规则的加密方式被称为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJThEJUU3JUE4JUIxJUU1JUFGJTg2JUU5JTkxJUIwJUU1JThBJUEwJUU1JUFGJTg2" title="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称加密算法<i class="fa fa-external-link"></i></span>。那么加密和解密的规则（简称密钥）的保护就显得尤其重要，传递密钥的风险也一直是个隐患。<br>&emsp;直到1976年，两位美国计算机学家：迪菲（W.Diffie）、赫尔曼（M.Hellman）提出了一种崭新构思，可以在不直接传递密钥的情况下完成密钥交换，开创了密码学研究的新方向。这就是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJGJUFBJUU4JThGJUIyLSVFOCVCNSVBQiVFNyU4OCVCRSVFNiU5QiVCQyVFNSVBRiU4NiVFOSU5MSVCMCVFNCVCQSVBNCVFNiU4RiU5Qg==" title="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">“迪菲赫尔曼密钥交换”<i class="fa fa-external-link"></i></span>算法，其仍然是一种对称加密算法，只是密钥不再需要传递。交换原理如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2019/1/7/168275fb2e34d666?w=834&amp;h=476&amp;f=png&amp;s=93483" alt="迪菲赫尔曼密钥交换原理"><br>其中a，b是在通信两端本地的随机数，g是模p的一个<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThFJTlGJUU2JUEwJUI5" title="https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9">原根<i class="fa fa-external-link"></i></span>，K是交换后产生的密钥，安全性来源于当p非常大时，已知g，p，A，B很难反算出a，b。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUE2JUJCJUU2JTk1JUEzJUU1JUFGJUI5JUU2JTk1JUIw" title="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0">离散对数问题<i class="fa fa-external-link"></i></span>是该算法的基础。<br>&emsp;1977年，三位麻省理工学院的数学家 罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起设计了一种算法，可以实现非对称加密。这就是用他们三个人的名字命名的算法–<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUlNBJUU1JThBJUEwJUU1JUFGJTg2JUU2JUJDJTk0JUU3JUFFJTk3JUU2JUIzJTk1" title="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA<i class="fa fa-external-link"></i></span>算法。<br>&emsp;要弄清楚RSA的加密原理，先要知道<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFDJUE3JUU2JThCJTg5JUU1JUFFJTlBJUU3JTkwJTg2XyglRTYlOTUlQjAlRTglQUUlQkE=" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA">欧拉定理<i class="fa fa-external-link"></i></span>)：  </p><blockquote><p>对于两个互质的正整数m、n，m^φ(n) mod n ≡ 1<br>当m&lt;n时不难推导出：m^(k*φ(n)) mod n ≡ 1<br>进一步得到：m^(k*φ(n)+1) mod n ≡ m </p></blockquote><p>基于此还需要理解一个概念，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUE4JUExJUU1JThGJThEJUU1JTg1JTgzJUU3JUI0JUEw" title="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0">模反元素<i class="fa fa-external-link"></i></span>：  </p><blockquote><p>如果两个正整数e和x互质，那么一定可以找到整数d，使得 e*d-1 被x整除。那么d就是e对于x的“模反元素”<br>即e<em>d mod x ≡ 1<br>等同于 e\</em>d ≡ k*x + 1，k为正整数  </p></blockquote><p>敲黑板！！！关键来了，上面两个转换的结果一碰撞，Duang！就碰出了我们RSA的核心算法：  </p><blockquote><p>当e与φ(n)互质时，m^(e*d) mod n ≡ m  </p></blockquote><p>鸡不鸡冻，开不开森！还有点迷糊？没关系，来继续：  </p><blockquote><p>假设我们对m进行加密传输<br>加密：m^e mod n = c，<br>解密：c^d mod n = m^(e*d) mod n = m  </p></blockquote><p>上述过程中，<strong>n+e就是RSA中的公钥，n+d就是RSA中的私钥，c是加密后的密文。</strong></p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol><li>n会非常大，长度一般为1024个二进制位，现在稳妥一点的长度为2048个二进制位。（目前人类已经分解的最大整数，232个十进制位，768个二进制位）  </li><li>因为需要求出φ(n)，所以根据<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUFDJUE3JUU2JThCJTg5JUU1JTg3JUJEJUU2JTk1JUIw" title="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数<i class="fa fa-external-link"></i></span>特点，最简单得到n的方式是由两个质数相乘: 质数：p1、p2<br>Φ(n) = (p1 - 1) * (p2 - 1)</li><li>最终由φ(n)得到 e 和 d   </li></ol><p>总共生成6个数字：p1、p2、n、φ(n)、e、d  </p><h3 id="关于RSA的安全："><a href="#关于RSA的安全：" class="headerlink" title="关于RSA的安全："></a>关于RSA的安全：</h3><p>除了公钥用到了n和e 其余的4个数字是不公开的。<br>目前破解RSA得到私钥d的思路如下：</p><ol><li>由于e*d = φ(n)*k + 1。e是公开的，那必须要知道φ(n)</li><li>要得到φ(n)，必须知道p1 和 p2</li><li>由于 n = p1 * p2，所以只有将n因数分解才能算出p1 p2</li><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTg3JThGJUU1JUFEJTkwJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJB" title="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">量子计算机<i class="fa fa-external-link"></i></span>如果成功诞生，现在通行于银行及网络等处的RSA加密算法可以破解，也会瓦解所有基于大质数因式分解算力逆天而衍生出的加密算法。</li></ol><p>后续会对iOS证书签名相关原理进行分析，同时把常见的加密算法做一下梳理和比较，并附上每种算法在iOS中的代码实现。欢迎一起交流学习心得~</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
