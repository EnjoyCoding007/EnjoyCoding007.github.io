<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[撸一个 iOS 重签名脚本]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%92%B8%E4%B8%80%E4%B8%AAiOS%E9%87%8D%E7%AD%BE%E5%90%8D%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[上一篇iOS APP签名详解我们了解了iOS签名的机制和原理，这一篇我们一起来动手写一个自动重签名的脚本，懒是程序员乃至人类进步的终极力量，造轮子写工具可以极大的避免重复性工作，为我们节省更多的时间放在思考上，话不多说撸起袖子开始干： 第一步：获取脱壳的ipa包 从iTunes 12.6.3及以前的版本上直接下载 （macOS Mojave Doesn’t Support），这样获取到的是正版ipa，需要用Clutch、dumdecrypted等工具先脱壳，否则别人的加密验证不通过无法安装 各类助手上下载越狱版ipa包 越狱手机导出 Xcode打包 等等 这里我下载了微信的越狱版ipa包用来演示。 第二步：命令行实现重签名 将ipa解压缩后前往.app所在目录，输入 -d -vv WeChat.app``` 1234567891011121314151617181920212223 查看可执行文件的签名信息：![](https://user-gold-cdn.xitu.io/2019/1/22/1687194244bf3be8?w=1424&amp;h=376&amp;f=png&amp;s=245630)可以看到签名信息现在还是腾讯的 2. 输入： ```security find-identity -v -p codesigning``` 查看Mac本地的证书列表:![](https://user-gold-cdn.xitu.io/2019/1/22/16871950dcd0e283?w=1592&amp;h=272&amp;f=png&amp;s=114415) 记下你要用来签名的证书双引号（包括双引号）中的字符串，一会儿会用到 3. 确认ipa包是否已经脱壳，输入： ```cd WeChat.app``` ```otool -l WeChat | grep crypt``` 会输出：![](https://user-gold-cdn.xitu.io/2019/1/22/16871958f396421c?w=988&amp;h=244&amp;f=png&amp;s=94527) cryptid为0即为已脱壳，为1为加密状态。这里有两组数据是因为这是个支持两种CPU架构的可执行文件，可输入```file WeChat```查看可执行文件支持的架构：![](https://user-gold-cdn.xitu.io/2019/1/22/16871961777d44a5?w=1396&amp;h=142&amp;f=png&amp;s=108757)4. 删除无法签名的插件文件：PlugIns文件夹、Watch文件夹 5. 对.app文件夹内的Frameworks文件夹中的每一个framework强制重签名： ```codesign -fs 步骤2中记下的证书信息 要签名的.framework``` 注意不要遗漏，每一个framework都要用自己的证书重签一下6. 将自己的描述文件名改为embedded.mobileprovision，并拖入到.app中，再将.app中info.plist文件里的Bundle identifier改成我们自己的BundleID7. 在.app同级目录下新建一个entitlements.plist文件，查看描述文件内容： ```security cms -D -i embedded.mobileprovision```将Entitlements节点下的 ... ... 12345 复制粘贴到刚刚新建的entitlements.plist文件中8. 最后一步，对整个包签名，回到.app所在目录，输入： ```codesign -fs 步骤2中记下的证书信息 --no-strict --entitlements=entitlements.plist WeChat.app``` 签名成功！9. 打包：```zip -ry WeiChat.ipa Payload 以上，就是通过命令行一步步的实现应用重签名。 最后：撸自动重签名的脚本现在我就按照这个思路写脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#$&#123;SRCROOT&#125; 它是工程文件所在的目录TEMP_PATH=&quot;$&#123;SRCROOT&#125;/Temp&quot;#资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包ASSETS_PATH=&quot;$&#123;SRCROOT&#125;/APP&quot;#目标ipa包路径TARGET_IPA_PATH=&quot;$&#123;ASSETS_PATH&#125;/*.ipa&quot;#清空Temp文件夹rm -rf &quot;$&#123;SRCROOT&#125;/Temp&quot;mkdir -p &quot;$&#123;SRCROOT&#125;/Temp&quot;#----------------------------------------# 1. 解压IPA到Temp下unzip -oqq &quot;$TARGET_IPA_PATH&quot; -d &quot;$TEMP_PATH&quot;# 拿到解压的临时的APP的路径TEMP_APP_PATH=$(set -- &quot;$TEMP_PATH/Payload/&quot;*.app;echo &quot;$1&quot;)# echo &quot;路径是:$TEMP_APP_PATH&quot;#----------------------------------------# 2. 将解压出来的.app拷贝进入工程下# BUILT_PRODUCTS_DIR 工程生成的APP包的路径# TARGET_NAME target名称TARGET_APP_PATH=&quot;$BUILT_PRODUCTS_DIR/$TARGET_NAME.app&quot;echo &quot;app路径:$TARGET_APP_PATH&quot;rm -rf &quot;$TARGET_APP_PATH&quot;mkdir -p &quot;$TARGET_APP_PATH&quot;cp -rf &quot;$TEMP_APP_PATH/&quot; &quot;$TARGET_APP_PATH&quot;#----------------------------------------# 3. 删除extension和WatchAPP.个人证书没法签名Extentionrm -rf &quot;$TARGET_APP_PATH/PlugIns&quot;rm -rf &quot;$TARGET_APP_PATH/Watch&quot;#----------------------------------------# 4. 更新info.plist文件 CFBundleIdentifier# 设置:&quot;Set : KEY Value&quot; &quot;目标文件路径&quot;/usr/libexec/PlistBuddy -c &quot;Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER&quot; &quot;$TARGET_APP_PATH/Info.plist&quot;#----------------------------------------# 5. 给MachO文件上执行权限# 拿到MachO文件的路径APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`#上可执行权限chmod +x &quot;$TARGET_APP_PATH/$APP_BINARY&quot;#----------------------------------------# 6. 重签名第三方 FrameWorksTARGET_APP_FRAMEWORKS_PATH=&quot;$TARGET_APP_PATH/Frameworks&quot;if [ -d &quot;$TARGET_APP_FRAMEWORKS_PATH&quot; ];thenfor FRAMEWORK in &quot;$TARGET_APP_FRAMEWORKS_PATH/&quot;*do#签名/usr/bin/codesign --force --sign &quot;$EXPANDED_CODE_SIGN_IDENTITY&quot; &quot;$FRAMEWORK&quot;donefi 将写好的脚本直接丢到.xcodeproj同级目录中 Xcode –&gt; Build Phases –&gt; New Run Script Phase: 现在，将你要重签名的ipa包丢到在工程目录下新建的文件夹APP中（这个文件夹跟你写的脚本中的目标文件夹同名即可），直接Run！任何应用都会在你的真机上跑起来了！这也是后面讲逆向的准备工作。 了解了iOS签名的原理再做重签名，我相信上面的每一步为什么那么做，你自然也很清楚了，写起脚本来自然思路也很清晰~如果你在实践中遇到任何问题，欢迎留言交流~]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS APP签名机制详解]]></title>
    <url>%2F2019%2F01%2F18%2FiOS%20APP%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[苹果的需求 为了保证系统的安全性，所有iPhone上安装的应用必须是经过苹果授权的 安装包不需要上传到App Store也能被安装 （开发调试 企业灰度） 防止证书权限滥用：设备限制、指定APP、iCloud/PUSH/后台运行等附加权限控制 苹果的解决方案：双层代码签名+描述文件: 这里画一张图附上： &emsp;在iOS出来之前，主流的操作系统（MacOS/Windows）软件随便从哪里下载都能运行，系统安全存在隐患，盗版软件、病毒入侵、静默安装等等，苹果希望解决类似的问题，保证在iPhone iOS上的APP都是经过苹果官方允许的，怎样保证呢？就是通过代码签名。 &emsp;如果要实现验证，最简单的方式就是苹果官方生成一对RSA公私钥，在iOS系统中内置一个公钥，私钥由苹果后台保存，我们上传APP到App Store时苹果后台用私钥对APP数据进行加密，iPhone下载APP后用公钥验证这个签名就可以确认APP是否经过允许或被三方篡改过。但是，我们安装APP并不仅仅只有App Store这一个方式，比如真机调试、企业包等，所以只靠这个简单的数字签名方式是不够的。 &emsp;于是苹果设计了双层签名的机制，我们都知道iOS的应用开发必须在Mac系统下进行，正是由于这个依赖关系，双层签名才有了基础： 在Mac系统中生成一对非对称加密算法的公私钥M（Xcode会帮你做好） 苹果自己有固定的一对公私钥，正如上述最简单的代码签名中提到的：私钥A在苹果后台，公钥A在每个iOS系统的手机中 把公钥M以及一些开发者信息（也就是CSR文件）发送给苹果后台，用苹果后台的私钥A对公钥M签名，得到一份包含公钥M以及其签名结果的数据就是证书（.p12）。 在开发时，当我们打包时会用本地的私钥M（也就是可导出给小伙伴的开发者证书）对这个APP进行签名，同时把第三步得到的证书一起打包进APP里，然后安装到手机上（真机联调）或者提交App Store审核 安装时，iOS系统取得内置公钥A去验证公钥M的数字签名证书是否正确 验证公钥M是苹果认证过的后，再用公钥M去验证APP的签名，这样就间接验证了这个APP的安装是经过苹果允许的了（注意这里只验证安装行为，不验证APP是否被改动，因为开发阶段APP内容总是不断变化的） &emsp;有了上面的过程已经可以保证开发者的认证和程序的安全了，但是如果只有上述的过程，那岂不是只要申请了一个证书就可以安装到所有的iOS设备了？所以，苹果又增加了授权文件（Provisioning profile）的验证，Provisioning profile一般包括三样东西：证书、APP ID、设备。 &emsp;描述文件是在AppleDevelop网站创建的(在Xcode中填上AppleID它会代办创建)，Xcode运行时会打包进入APP内。在开发时，编译完一个 APP 后，用本地的私钥M对这个APP进行签名，同时把从苹果服务器得到的 Provisioning Profile 文件打包进APP里，文件名为embedded.mobileprovision，当把APP安装到手机上时，iOS系统会进行验证。 &emsp;以上就是iOS应用签名的原理，下一篇基于这个原理我会手撸一个自动重签名的脚本。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈iOS中常用加密算法的使用]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%B5%85%E8%B0%88iOS%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;以前如果我们忘记了登录密码，通常可以通过“找回密码”这样的方式拿回密码，那说明你的隐私数据在他们的数据库中是明文保存的，现在请切记：如果哪个平台还有这样的方式请立刻马上注销你的账号，并避免在任何其他平台使用这个平台使用过的密码。请坚信：在网络世界中，只要是明文存在或可逆的东西，都是不安全的。没有哪家公司会告诉你他们的数据库被拖库过，你更无法想象现在的黑色产业早已让你毫无隐私。 &emsp;千万别一个密码走天下，一定要定期改密码！ &emsp;道高一尺魔高一丈，对用户隐私及一些敏感数据的保护越来越重要，在iOS中，苹果封装了Security.framework、CommonCrypto.framework这两个保护信息安全的库，为我们提供了安全相关的通用API： RSA：公私钥的生成、公钥加密、私钥解密、私钥签名、公钥验签功能，证书信息的读取，以及密钥在KeyChain中存储，查找，删除等功能 哈希：SHA1、SHA224、SHA256、SHA384、SHA512MD2、MD4、MD5 对称加密：DES、3DES、AES &emsp;这一篇文章，我们就以“用户输入密码，登录，服务端验证用户信息，用户上传隐私数据”这个常见场景为例，分享一些密码学常识和加密时常用的防破解技巧，至于上述算法相关API的使用，文末我会附上iOS中所有常用加密API使用的demo，这里就不浪费篇幅贴代码了。先说两个保护用户隐私的原则： 网络上不允许明文传递用户隐私信息 本地不允许明文保存用户隐私信息 &emsp;再了解下几种算法的特点： 对称加密 加密解密共用一个密钥 DES 数据加密标准，安全强度不够已经很少用了 3DES 使用三个密钥对相同的数据执行三次加密 强度略高，但密钥的保护一直是个隐患所以也不常用 AES 高级密码标准 用得最多 两种常用加密模式： ECB：&emsp;最基本的加密方式，无初始向量，相同的明文永远生成不变的密文，容易受到密码本重放攻击，很少用 CBC：&emsp;明文被加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。&emsp;可以有效的保证密文的完整性，如果一个数据块在传递是丢失或改变，后面的数据将无法正常解密。 RSA关于RSA相关知识请参考：非对称加密–RSA原理浅析RSA的主场-证书签名之OpenSSL演示 这里不再赘述。 哈希算法也就是常说的散列函数，严格意义上它并不是一种加密算法，但它常常与加密算法一起出现，作为一种组合方式。哈希具有以下特点： 算法是公开的 对相同的数据运算，得到的结果是一样的 同一算法对不同的数据运算，得到的结果长度是固定的，如MD5的结果一定是128bit，32个字符(16进制表示)，所以散列碰撞是必然的偶然 不可逆，但是可以通过彩虹表去反查询 通常作为信息“指纹”–信息摘要，用来做数据识别（版权、搜索引擎、数字签名等）。 实际应用&emsp;知道了每种算法的特点，回到应用场景：用户输完密码点击登录时，我们如何保证用户信息是足够安全的呢？ 对称加密：密钥传输有隐患，且在客户端加密前和服务端解密后会出现明文，不安全。 RSA：安全性高，网络劫持很难破解，但是服务端拿到客户端加密后的密文怎么办呢？用私钥解密，解密之后拿到明文信息？大忌，没有哪个服务端是安全的，更没法保证数据库人员的个人泄露用户信息。不可取。 哈希： 直接MD5？用户输入常规组合概率很大，暴力破解风险很高，不可取。本地加盐，很变态的盐？安全性有一定保障，缺点是盐写死在程序里了，写代码的人也有泄露的可能性，一旦泄漏结果是毁灭性的，不可取。 HMAC：Keyed-Hashing for Message Authentication，这是一种使用单向散列函数来构造消息认证码的方案，而不是算法。&emsp; 在第一次注册时，服务端下发一个随机密钥 n，这个密钥会在客户端和服务端都保存一份（支持服务端更新），客户端的 n 用作以后每次登录时的“盐”参与第一次散列运算，并将第一次散列运算的结果 s 发给服务端作为用户密码信息保存到数据库中，这样用户的真实密码无论是客户端还是服务端都不知道，也不存在数据库被拖库泄露的问题。服务端保存的 n 用于当用户换设备登录或卸载重新装时验证通过后再次将 n 下发给客户端保存。&emsp;用户每次登录时，服务器会再动态下发一个随机值作为密钥，并在会话中记下这个随机值 r，客户端先用本地保存的 n 对用户密码做散列运算得到 s ，再用 r 对 s 做一次MAC（Message Authentication Codes）运算并将运算结果发送给服务端，服务端也从数据库中取出用户的密码散列值做同样的运算，并将结果与客户端进行对比。为了防止网络中间人攻击，还需将时间戳（服务器时间，一般精确到分钟）参与校验，黑客就很难破解了。这是目前最主流的安全方案。 &emsp;现在用户登录成功，现在要上传一份敏感数据，我们如何保证数据的完整性呢？结合上面的分析，推荐AES的CBC加密方式，安全性高，还能保证完整性，数字签名同样也可以验证数据完整性，用RSA对数据的hash值进行加密，服务端接收完数据后，用私钥解密得到hash值，与接收数据的hash值作比对。 补充：iOS中常见加密算法的使用：EncryptDemo在Demo中，对称加密AES的加密解密函数： CCCryptorStatus CCCrypt( CCOperation op, /* kCCEncrypt, etc. */ CCAlgorithm alg, /* kCCAlgorithmAES128, etc. */ CCOptions options, /* kCCOptionPKCS7Padding, etc. */ const void *key, size_t keyLength, const void *iv, /* optional initialization vector */ const void *dataIn, /* optional per op and alg */ size_t dataInLength, void *dataOut, /* data RETURNED here */ size_t dataOutAvailable, size_t *dataOutMoved) API_AVAILABLE(macos(10.4), ios(2.0)); 调用CCCrypt时，用户敏感数据不要直接作为参数传递，否则逆向很容易hook到，通常的做法是对敏感数据做异或、加盐等处理，具体根据需要自己设计。 iOS app签名机制详解 推荐阅读：iOS应用签名(上)iOS应用签名(下) iOS中对钥匙串的操作推荐：SSKeyChain 实践出真知，下篇再会~老规矩，有错误请积极指正，有问题请踊跃留言。 更多一手好文更新，请关注我的个人微信公众号：面向未来编程]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA的主场-证书签名&OpenSSL演示]]></title>
    <url>%2F2019%2F01%2F09%2FRSA%E7%9A%84%E4%B8%BB%E5%9C%BA-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D%26OpenSSL%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[&emsp;在上一篇非对称加密–RSA原理浅析中，我们了解了RSA加密的数学原理，RSA的安全性目前虽然得到公认，但它同样也有缺点：加密速度慢、性能较低，不适合对大文件直接做加密，需要加密的原始数据通常会先经过Base64、Hash、对称加密等处理后，再用RSA对其进行加密，因此RSA最主要的应用场景，是数字签名–对数据做身份/合法性校验。&emsp;权威的证书颁发机构–躺着赚钱的CA，就是用的RSA这一套算法，这一篇我们一起用命令行来逐步拆解证书的生成过程，揭开证书背后的秘密。Talk is cheap，show you the code，Come on！ 什么是OpenSSL&emsp;SSL大家都不陌生，我们访问网站的时候，以HTTPS开头的表示你和服务器之间传输的数据经过了加密，这里所使用的加密协议就是SSL（Secure Sockets Layer，后来又推出了它的后续版本，改名叫TLS）。也就是说，把HTTP协议经过一层SSL协议进行加密包装，就变成了HTTPS。当然，SSL/TLS还用在很多协议中，例如VPN、加密的电子邮件协议等。&emsp;那OpenSSL是啥？在SSL协议中，我们使用了很多密码学手段来保护数据，其中包括对称密码、公钥密码、数字签名、证书、完整性校验、伪随机数生成等。由于这些算法和操作都非常复杂，于是开源社区就开发了一套库，这个库里面提供了很多现成的标准方法，其他开发者只要用正确调用这些方法，就可以实现SSL协议中的各种加密/解密操作了。因此，OpenSSL是一套开源的密码学工具包（open source cryptography toolkit）。情理之中的，OpenSSL也支持了RSA算法，接下来我们就用OpenSSL在macOS的终端上为大家演示证书签名的每一个步骤。 RSA加密、证书生成终端演示&emsp;为了便于观察，请开辟并前往一个空文件夹下开始你的表演~输入：12345openssl genrsa -out private.pem 2048``` 此时目录中出现一个private.pem文件，这个文件包含了私钥信息 根据私钥生成公钥 输入： openssl rsa -in private.pem -pubout -out public.pem1分别查看文件中的内容： cat private.pem1234```cat public.pem``` 你会得到这样类似这样的结果： —–BEGIN RSA PRIVATE KEY—–Base64编码的内容—–END RSA PRIVATE KEY—–123456```-----BEGIN PUBLIC KEY-----Base64编码的内容-----END PUBLIC KEY-----``` 现在我们随便写一个txt文件作为要加密的数据： echo “hello word!“ &gt; message.txt1用公钥对其加密： openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt12查看加密后的文件：```cat enc.txt```，你只能看到一堆乱码 用私钥对加密文件解密： openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt123查看解密结果：```cat dec.txt```，与你的message.txt内容完美吻合~ 上面的过程反过来（私钥加密 公钥解密）一个道理，但执行命令有点区别： 用私钥对其加密： openssl rsautl -sign -in message.txt -inkey private.pem -out enc.bat1用公钥对加密文件解密： openssl rsautl -verify -in enc.bat -inkey public.pem -pubin -out dec.txt1&amp;emsp;至此，我们已经完成了RSA加密解密的操作，那我们开发中用的证书跟它们有什么关系呢？做iOS开发的都用钥匙串从CA请求过csr文件，其实就是根据当前Mac内置的私钥（当然你也可以自己指定私钥）生成对应的公钥，生成的csr文件包含了公钥证书原始文件+你的服务器信息和单位等信息。我们来用命令执行这一步操作： openssl req -new -key private.pem -out rsacert.csr1根据提示依次输入下列信息并回车: Country Name (2 letter code) []:State or Province Name (full name) []:Locality Name (eg, city) []:Organization Name (eg, company) []:Organizational Unit Name (eg, section) []:Common Name (eg, fully qualified host name) []:Email Address []:A challenge password []:1拿到带着公钥信息的csr文件之后，下一步就是交给CA认证中心进行签名，也就是让CA盖个章（一个章一年五千大洋@_@，如果你的https用自签的证书那别人访问时有不安全提示就是因为你没有CA盖的这个章，不被承认是安全的）： openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt1这时得到的crt文件是Base64编码的，我们需要转成DER二进制格式的证书才能直接使用： openssl x509 -outform der -in rsacert.crt -out rsacert.der123这个rsacert.der文件就是包含了我们公钥信息的证书！ ![](https://user-gold-cdn.xitu.io/2019/1/9/16832dfe1997dfd0?w=1022&amp;h=826&amp;f=png&amp;s=172453)最后一步，导出公钥证书对应的私钥证书： openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt12345![](https://user-gold-cdn.xitu.io/2019/1/9/16832e25c325de5f?w=1004&amp;h=816&amp;f=png&amp;s=165762)输入两次私钥证书的密码就得到了我们最熟悉的.p12文件。 &amp;emsp;当然，在我们实际开发中不会同时拿到这两个证书，这里只是给大家演示它们之间的关系，后面我会对苹果的双向验证(双层签名)原理专门写一篇文章讲解 ### 补充&amp;emsp;关于.pem文件内部的数据结构可以通过命令 openssl rsa -in private.pem -text -out ptivate.txt`查看，ptivate.txt文件中每一项的具体意义请参考（PEM格式）解析&emsp;在上面的命令中如果有些不明觉厉的玩意儿，那多半是你对证书相关的文件编码格式、协议和扩展名不太熟悉，不要慌，我已经为你准备好了加餐。 高能预警——证书文件编码格式、扩展名、协议科普&emsp;我们统一采用X.509的格式标准生成证书，接触过证书的同学看到：pem、der、pfx、jks、kdb、cer、key、csr、crt、crl、ocsp、scep等这些字眼一定不会完全陌生，这些东东究竟是个啥？赶紧来一探究竟，有描述不准确的地方还望指正： 编码格式 DER：（Distinguished Encoding Rules）的缩写，它是大多数浏览器的缺省格式，并按 ASN1 DER 格式存储，它是无报头的。可包含所有私钥、公钥和证书。 PEM：（Privacy Enhanced Mail）的缩写，它是OpenSSL默认采用的信息存放方式，它存储用Base64编码的DER格式数据，用ASCII报头包围，因此适合系统之间的文本模式传输。可以包括所有私钥、公钥和证书。 文件扩展名 .pem - (隐私增强型电子邮件) DER编码的证书再进行Base64编码的数据存放在”—–BEGIN CERTIFICATE—–”和”—–END CERTIFICATE—–”之中 .cer, .crt, .der - 通常是DER二进制格式的证书，但Base64编码后也很常见 .p7b, .p7c - PKCS#7 SignedData structure without data, just certificate(s) or CRL(s)，加密消息语法(pkcs7),是各种消息存放的格式标准。这些消息包括:数据、签名数据、数字信封、签名数字信封、摘要数据和加密数据。 .p12 - PKCS#12格式，包含证书的同时可能还有带密码保护的私钥 .pfx - PFX，PKCS#12之前的格式（通常用PKCS#12格式，比如那些由IIS产生的PFX文件） .jks - 通常可以将Apache/OpenSSL使用的“.key文件 + .crt文件”格式转换为标准的Java Key Store(JKS)文件。JKS文件格式被广泛的应用在基于JAVA的WEB服务器、应用服务器、中间件。你可以将JKS文件导入到TOMCAT、WEBLOGIC 等软件 .kdb - 通常可以将Apache/OpenSSL使用的“.key文件 + .crt文件”格式转换为标准的IBM KDB文件。KDB文件格式被广泛的应用在IBM的WEB服务器、应用服务器、中间件。你可以将KDB文件导入到IBM HTTP Server、IBM Websphere 等软件 .csr - 证书请求文件(Certificate Signing Request)。生成X509数字证书前,一般先由用户提交证书申请文件,然后由 CA 来签发证书。 .key - 一般指PEM格式的私钥文件，也可能是DER格式的 .crl - 证书吊销列表 (Certification Revocation List)是一种包含撤销的证书列表的签名数据结构。CRL是证书撤销状态的公布形式,CRL 就像信用卡的黑名单,用于公布某些数字证书不再有效。CRL是一种离线的证书状态信息。它以一定的周期进行更新。CRL可以分为完全CRL和增量CRL。在完全CRL中包含了所有的被撤销证书信息,增量CRL由一系列的CRL来表明被撤销的证书信息,它每次发布的CRL是对前面发布CRL的增量扩充。基本的CRL信息有:被撤销证书序列号、撤销时间、撤销原因、签名者以及 CRL 签名等信息。基于CRL的验证是一种不严格的证书认证。CRL能证明在CRL中被撤销的证书是无效的。但是,它不能给出不在CRL中的证书的状态。如果执行严格的认证,需要采用在线方式进行认证,即OCSP认证。一般是由CA签名的一组电子文档，包括了被废除证书的唯一标识（证书序列号），CRL用来列出已经过期或废除的数字证书。它每隔一段时间就会更新，因此必须定期下载该清单，才会取得最新信息 协议 OCSP – 在线证书状态协议(Online Certificate Status Protocol,rfc2560)，用于实时表明证书状态。OCSP 客户端通过查询 OCSP 服务来确定一个证书的状态,可以提供给使用者一个或多个数字证书的有效性资料，它建立一个可实时响应的机制，让用户可以实时确认每一张证书的有效性，解决由CRL引发的安全问题。。OCSP 可以通过 HTTP协议来实现。rfc2560 定义了 OCSP 客户端和服务端的消息格式 SCEP － 简单证书注册协议（Simple Certificate Enrollment Protocol），基于文件的证书登记方式需要从您的本地计算机将文本文件复制和粘贴到证书发布中心，和从证书发布中心复制和粘贴到您的本地计算机。SCEP可以自动处理这个过程但是CRLs仍然需要手动的在本地计算机和CA发布中心之间进行复制和粘贴 实践出真知，下篇再会~ 老规矩，有问题请踊跃留言。更多一手好文更新请关注我的个人微信公众号：面向未来编程]]></content>
  </entry>
  <entry>
    <title><![CDATA[非对称加密--RSA原理浅析]]></title>
    <url>%2F2019%2F01%2F07%2F%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86--RSA%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[来龙去脉&emsp;在1976年以前，所有的加密方法都是同一种模式：加密、解密使用同一种算法。在交互数据的时候，彼此通信的双方就必须将规则告诉对方，否则没法解密。这种加密与解密使用同一规则的加密方式被称为对称加密算法。那么加密和解密的规则（简称密钥）的保护就显得尤其重要，传递密钥的风险也一直是个隐患。&emsp;直到1976年，两位美国计算机学家：迪菲（W.Diffie）、赫尔曼（M.Hellman）提出了一种崭新构思，可以在不直接传递密钥的情况下完成密钥交换，开创了密码学研究的新方向。这就是“迪菲赫尔曼密钥交换”算法，其仍然是一种对称加密算法，只是密钥不再需要传递。交换原理如下图所示：其中a，b是在通信两端本地的随机数，g是模p的一个原根，K是交换后产生的密钥，安全性来源于当p非常大时，已知g，p，A，B很难反算出a，b。离散对数问题是该算法的基础。&emsp;1977年，三位麻省理工学院的数学家 罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起设计了一种算法，可以实现非对称加密。这就是用他们三个人的名字命名的算法–RSA算法。&emsp;要弄清楚RSA的加密原理，先要知道欧拉定理)： 对于两个互质的正整数m、n，m^φ(n) mod n ≡ 1当m&lt;n时不难推导出：m^(k*φ(n)) mod n ≡ 1进一步得到：m^(k*φ(n)+1) mod n ≡ m 基于此还需要理解一个概念，模反元素： 如果两个正整数e和x互质，那么一定可以找到整数d，使得 e*d-1 被x整除。那么d就是e对于x的“模反元素”即ed mod x ≡ 1等同于 e\d ≡ k*x + 1，k为正整数 敲黑板！！！关键来了，上面两个转换的结果一碰撞，Duang！就碰出了我们RSA的核心算法： 当e与φ(n)互质时，m^(e*d) mod n ≡ m 鸡不鸡冻，开不开森！还有点迷糊？没关系，来继续： 假设我们对m进行加密传输加密：m^e mod n = c，解密：c^d mod n = m^(e*d) mod n = m 上述过程中，n+e就是RSA中的公钥，n+d就是RSA中的私钥，c是加密后的密文。 补充： n会非常大，长度一般为1024个二进制位，现在稳妥一点的长度为2048个二进制位。（目前人类已经分解的最大整数，232个十进制位，768个二进制位） 因为需要求出φ(n)，所以根据欧拉函数特点，最简单得到n的方式是由两个质数相乘: 质数：p1、p2Φ(n) = (p1 - 1) * (p2 - 1) 最终由φ(n)得到 e 和 d 总共生成6个数字：p1、p2、n、φ(n)、e、d 关于RSA的安全：除了公钥用到了n和e 其余的4个数字是不公开的。目前破解RSA得到私钥d的思路如下： 由于e*d = φ(n)*k + 1。e是公开的，那必须要知道φ(n) 要得到φ(n)，必须知道p1 和 p2 由于 n = p1 * p2，所以只有将n因数分解才能算出p1 p2 量子计算机如果成功诞生，现在通行于银行及网络等处的RSA加密算法可以破解，也会瓦解所有基于大质数因式分解算力逆天而衍生出的加密算法。 后续会对iOS证书签名相关原理进行分析，同时把常见的加密算法做一下梳理和比较，并附上每种算法在iOS中的代码实现。欢迎一起交流学习心得~]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何成为有效学习的高手]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9C%89%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%AB%98%E6%89%8B%2F</url>
    <content type="text"><![CDATA[不闲言赘语，直戳痛点，放下借口，共同面对内心的忐忑吧。 注：本文为得到专栏付费课程学习心得，分享给大家一起加快成长速度。 &emsp;高效学习，它没有一种准确的定义，它更是对一种学习状态的描述，一万小时理论我们都听过，但这个理论可能不适合我们99.9%的人，我想这个理论出现的目的其实是为了推翻人们对于天才的迷信，但是，一万小时理论所展现的那种学习或者说练习的场景跟你和我的生活、工作离得都很远，我们也不需要都成为世界级的高手。这个理论本身没有错，它在打破人们对于天才的迷信的同时，也打击了绝大部分成年人的信心：谁有功夫每天8小时练习，练10年呢？但我们常常需要在很短的时间里要掌握一些技能，而且要达到专业级别的水准，这要求我们必须在有限的业余碎片时间中，高效的有目的的学习，话不多说，进入正题。 让我们从七个关键词着手： 适合自己 学习手法 短时间 注意力 解决难题 设定目标 名师 接下来我会对这七个关键词主义展开来探讨，学习如何将他们有机的结合起来，形成一套可自控，可循环，甚至是可以升级的学习套路。此篇先消化前两个关键词。 1.找到适合你的学习方法&emsp; 先重点要给大家介绍的两种学习思维，自然主义和结构主义。自然主义是模仿式的学习，自然主义注重文本的本身，什么是文本？就是一门知识或者技能它表面上看起来的样子，遇到什么就学什么，积少成多，以量取胜。学完了就那样了，它就是你自己的了，你就可以去运用了。结构主义它侧重对结构和交互关系的一个认识，它提倡透过表面的现象去寻求底层的关系。也就是说你要学习的是一套能举一反三的系统，这种诉求为的是什么呢？体系化的去学习，学会之后的目的，一定是为了创造，是一种质变，它要的是一种质变。选对学习方式这是第一步。（学习比如像语言、乐器、书法这些东西，你可能要用自然主义的学习方法去学习才更有效果。如果你学比如像医药、艺术，或者经济学，那就应该用结构主义的方式来学了。） &emsp; 再谈谈学习速度和效率的提升，理论上可以分为两个阶段：第一是避免无效学习，也就是选对学习方式。然后就是尽可能通过更好的学习策略来把这个有效变为高效。最简单有效的技巧就是 ： &emsp; 把你的目标要拆碎，针对那些细节进行反复的练习。不要一开始就照顾全局。 如果还能以碎片化的方式挤出更多的时间来学习的话，那效果会更好。 碎片化学习的真相&emsp; 碎片化学习的真相是碎片化学习一定要基于搜索，搜索是什么意思？意思就是你要带着困惑和问题去执行碎片化的学习，最终的效果一定是要把这些碎片给链接起来。在一段时间内，你的头脑当中应该始终有一个课题，这些碎片它不是满地的落叶，而是我们可以把它比喻成一个打碎的瓷器所产生的碎片。你要有目的的去拾获这些碎片，而不是乱捡。就算碎片化知识是树叶，你也得先有树根、树干和树枝。碎片化学习要的是枝繁叶茂，而不是捡几片树叶回来夹在书里边。那就属于一种情绪化的行为。 &emsp; 话说回来，碎片化学习它终究是有局限性的，因为它缺乏思考，缺乏辩论，缺乏与人交流的这些环节。所谓学而不思则罔嘛。碎片划拉的越多，可能越糊涂了。但是，无论如何，碎片化学习作为一种成年人学习的补充手段，无疑它是有很大力量的。 &emsp; 我必须还要提醒你一件事情！！！有一种假的碎片化学习叫做收藏。你一定对这个东西非常熟悉，收藏这个按钮是非常常见的，在很多app和软件当中，所谓一种人性化的设置。它的存在能够非常大程度缓解人们的焦虑。但这种缓解它其实不是真正的缓解，它只是给你造成一种幻觉，就是收藏了这些知识就是你的了。但其实，如果你收藏完了不看的话，你不去碰它，它并不是你的。你必须要破除掉这种幻觉。 2.不谈兴趣，用任务驱动学习&emsp; 学习，很多人提倡培养兴趣，让自己爱上学习，通常这些人最后都放弃了。以至于慢慢的习惯了没兴趣所以学不会、学不好的自我认知。学不会：连门都没入，这可能确实跟天赋有关，你让身高一米五的去打NBA这种情况我们就不讨论了；学不好：没达到某种专业的程度。兴趣无疑是最好的老师，这句话没毛病，但是如果明明没兴趣的东西，非要让你喜欢上它，这显然是极小概率事件，生活没时间给你去玩小概率。 &emsp; 一个很浅显的道理，人做任何事都是要回报的，所以一个人能带着多大的痛苦去做一件事，那是因为做成了这事儿会收获更大的利益。人做事的驱动有两个方面，一个是内部驱动，兴趣就是最大的内部驱动；一个是外部驱动，也就是完成目标之后收获的利益，既然你对该做的事没兴趣，那就干脆别浪费心思培养兴趣了，我要说的是，成年人学习不需要培养兴趣，应该用任务来驱动。你可能仍然会说，我没有任务啊，我找不到任务啊。任务到处都是，生活中的任务驱动，职场中的职业强迫，以教为学这些都是任务，找不到任务的唯一可能是你对未来的自己缺少预期。 &emsp; 生活中的驱动，比如厨艺、摄影、英语，现在的食品安全现状你还打算吃多久的外卖？想记录属于自己的美好记忆总觉得拍的照片经不起回味？出国游、面对各种英文文档没有翻译工具寸步难行？职场中的驱动，比如领域专业度、语言表达力、情绪与财富管理，部门每年加薪名额就那么点凭什么让老板优先考虑你呢？经常词不达意引起误会甚至错失良机？任性买买买快三十了还没房没车？以教为学，无论你学了什么，一旦你可以教别人了，你就不再是无业了。而且你还不是给人打工，你是自由职业者。以教为学一方面可以是自己对自己设置的一个任务和目标，不断地督促自己，另一方面其实会让你学的更好更透彻。 &emsp; 补充一点：你在心态上要有一种自觉，自己来聘请自己，让自我预期的小目标不断指引着持续学习，无论你在生活还是工作当中做任何事情都要这样做，不要心血来潮一股猛劲儿三分钟就疲了。 愿你有所收获 ( ゜- ゜)つロ乾杯🍻]]></content>
  </entry>
</search>
